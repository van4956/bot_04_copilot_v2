Analyze the bot_04_copilot_v2 repository.

README:
# Telegram Bot Copilot v2

*вторая версия бота для повседневных нужд*


Repository Structure: bot_04_copilot_v2
/.dockerignore
/.env.example
/.gitignore
/Dockerfile
/LICENSE
/README.md
/app.py
/common/
/config_data/
/database/
/docker-compose.yml
/filters/
/handlers/
/locales/
/middlewares/
/prescription.txt
/requirements.txt
/testing/
/testing/gpt.py
/testing/ice.py
/middlewares/counter.py
/middlewares/db.py
/middlewares/locale.py
/middlewares/throttle.py
/locales/en/
/locales/ru/
/locales/ru/LC_MESSAGES/
/locales/ru/LC_MESSAGES/bot_00_template.po
/locales/en/LC_MESSAGES/
/locales/en/LC_MESSAGES/bot_00_template.po
/handlers/admin.py
/handlers/cookbook.py
/handlers/currency.py
/handlers/donate.py
/handlers/group.py
/handlers/llm.py
/handlers/other.py
/handlers/owner.py
/handlers/private.py
/handlers/start.py
/handlers/weather.py
/filters/chat_type.py
/filters/find_usernames.py
/filters/is_admin.py
/filters/is_owner.py
/filters/member_can_restrict.py
/database/influxdb/
/database/models.py
/database/orm_cookbook.py
/database/orm_users.py
/database/postgres/
/database/postgres/.gitkeep
/database/influxdb/.gitkeep
/config_data/config.py
/common/comands.py
/common/image_cat/
/common/images/
/common/keyboard.py
/common/text_list_.py
/common/images/image_about.jpg
/common/images/image_updates.jpg
/common/image_cat/100030.jpg
/common/image_cat/photo_2024-02-28_21-43-11.jpg
/common/image_cat/photo_2024-02-28_21-43-50.jpg
/common/image_cat/photo_2024-02-28_21-44-47.jpg
/common/image_cat/photo_2024-02-28_21-46-45.jpg
/common/image_cat/photo_2024-02-28_21-48-57.jpg
/common/image_cat/photo_2024-02-28_21-49-51.jpg
/common/image_cat/photo_2024-02-28_21-50-18.jpg
/common/image_cat/photo_2024-02-28_21-50-28.jpg
/common/image_cat/photo_2024-02-28_21-50-54.jpg
/common/image_cat/photo_2024-02-28_21-55-46.jpg
/common/image_cat/photo_2024-02-28_21-55-53.jpg
/common/image_cat/photo_2024-02-28_21-56-04.jpg
/common/image_cat/photo_2024-02-28_21-56-16.jpg
/common/image_cat/photo_2024-02-28_21-56-26.jpg
/common/image_cat/photo_2024-02-28_21-56-43.jpg
/common/image_cat/photo_2024-02-28_21-57-03.jpg
/common/image_cat/photo_2024-02-28_21-57-16.jpg
/common/image_cat/photo_2024-02-28_21-57-23.jpg
/common/image_cat/photo_2024-02-28_21-57-24.jpg
/common/image_cat/photo_2024-02-28_21-57-26.jpg
/common/image_cat/photo_2024-02-28_21-57-30.jpg
/common/image_cat/photo_2024-02-28_21-57-43.jpg
/common/image_cat/photo_2024-02-28_21-57-45.jpg
/common/image_cat/photo_2024-02-28_21-57-58.jpg
/common/image_cat/photo_2024-02-28_21-58-21.jpg
/common/image_cat/photo_2024-02-28_21-58-23.jpg
/common/image_cat/photo_2024-02-28_21-58-25.jpg
/common/image_cat/photo_2024-02-28_21-59-05.jpg
/common/image_cat/photo_2024-02-28_21-59-14.jpg
/common/image_cat/photo_2024-02-28_21-59-36.jpg
/common/image_cat/photo_2024-08-14_08-22-15.jpg
/common/image_cat/photo_2024-11-10_19-36-38.jpg
/common/image_cat/photo_2024-11-10_19-36-44.jpg
/common/image_cat/photo_2024-11-10_19-36-47.jpg
/common/image_cat/photo_2024-11-10_19-36-49.jpg
/common/image_cat/photo_2024-11-10_19-37-00.jpg
/common/image_cat/photo_2024-11-10_19-37-10.jpg
/common/image_cat/photo_2024-11-10_19-37-21.jpg
/common/image_cat/photo_2024-11-10_19-37-26.jpg
/common/image_cat/photo_2024-11-10_19-37-29.jpg
/common/image_cat/photo_2024-11-10_19-37-34.jpg
/common/image_cat/photo_2024-11-10_19-37-41.jpg
/common/image_cat/photo_2024-11-10_19-37-55.jpg
/common/image_cat/photo_2024-11-10_19-38-01.jpg
/common/image_cat/photo_2024-11-10_19-38-04.jpg
/common/image_cat/photo_2024-11-10_19-38-08.jpg
/common/image_cat/photo_2024-11-10_19-38-25.jpg
/common/image_cat/photo_2024-11-10_19-38-33.jpg
/common/image_cat/photo_2024-11-10_19-38-38.jpg
/common/image_cat/photo_2024-11-10_19-38-45.jpg
/common/image_cat/photo_2024-11-10_19-38-55.jpg
/common/image_cat/photo_2024-11-10_19-39-13.jpg
/common/image_cat/photo_2024-11-10_19-39-28.jpg
/common/image_cat/photo_2024-11-10_19-40-05.jpg
/common/image_cat/photo_2024-11-10_19-40-12.jpg
/common/image_cat/photo_2024-11-10_19-40-37.jpg
/common/image_cat/photo_2024-11-10_19-40-48.jpg
/common/image_cat/photo_2024-11-10_19-40-57.jpg
/common/image_cat/photo_2024-11-10_19-41-13.jpg
/common/image_cat/photo_2024-11-10_19-41-31.jpg
/common/image_cat/photo_2024-11-10_19-41-39.jpg
/common/image_cat/photo_2024-11-10_19-41-43.jpg
/common/image_cat/photo_2024-11-10_19-41-49.jpg
/common/image_cat/photo_2024-11-10_19-42-12.jpg
/common/image_cat/photo_2024-11-10_19-42-16.jpg
/common/image_cat/photo_2024-11-10_19-42-28.jpg
/common/image_cat/photo_2024-11-10_19-42-33.jpg
/common/image_cat/photo_2024-11-10_19-42-39.jpg
/common/image_cat/photo_2024-11-10_19-42-50.jpg
/common/image_cat/photo_2024-11-10_19-43-01.jpg
/common/image_cat/photo_2024-11-10_19-43-09.jpg
/common/image_cat/photo_2024-11-10_19-43-13.jpg
/common/image_cat/photo_2024-11-10_19-43-17.jpg
/common/image_cat/photo_2024-11-10_19-43-23.jpg
/common/image_cat/photo_2024-11-10_19-43-27.jpg
/common/image_cat/photo_2024-11-10_19-43-34.jpg
/common/image_cat/photo_2024-11-10_19-43-39.jpg
/common/image_cat/photo_2024-11-10_19-43-47.jpg
/common/image_cat/photo_2024-11-10_19-44-02.jpg
/common/image_cat/photo_2024-11-10_19-44-07.jpg
/common/image_cat/photo_2024-11-10_19-44-12.jpg
/common/image_cat/photo_2024-11-10_19-44-17.jpg
/common/image_cat/photo_2024-11-10_19-44-27.jpg
/common/image_cat/photo_2024-11-10_19-44-38.jpg
/common/image_cat/photo_2024-11-10_19-44-42.jpg
/common/image_cat/photo_2024-11-10_19-44-47.jpg
/common/image_cat/photo_2024-11-10_19-44-51.jpg
/common/image_cat/photo_2024-11-10_19-44-57.jpg
/common/image_cat/photo_2024-11-10_19-45-00.jpg
/common/image_cat/photo_2024-11-10_19-45-03.jpg
/common/image_cat/photo_2024-11-10_19-45-09.jpg
/common/image_cat/photo_2024-11-10_19-45-12.jpg
/common/image_cat/photo_2024-11-10_19-45-15.jpg
/common/image_cat/photo_2024-11-10_19-45-20.jpg
/common/image_cat/photo_2024-11-10_19-45-28.jpg
/common/image_cat/photo_2024-11-10_19-45-45.jpg
/common/image_cat/photo_2024-11-10_19-45-54.jpg
/common/image_cat/photo_2024-11-10_19-45-57.jpg
/common/image_cat/photo_2024-11-10_19-46-02.jpg
/common/image_cat/photo_2024-11-10_19-46-10.jpg
/common/image_cat/photo_2024-11-10_19-46-15.jpg
/common/image_cat/photo_2024-11-10_19-46-20.jpg
/common/image_cat/photo_2024-11-10_19-46-27.jpg
/common/image_cat/photo_2024-11-10_19-46-37.jpg
/common/image_cat/photo_2024-11-10_19-46-46.jpg
/common/image_cat/photo_2024-11-10_19-46-50.jpg
/common/image_cat/photo_2024-11-10_19-46-53.jpg
/common/image_cat/photo_2024-11-10_19-46-56.jpg
/common/image_cat/photo_2024-11-10_19-47-04.jpg
/common/image_cat/photo_2024-11-10_19-47-10.jpg
/common/image_cat/photo_2024-11-10_19-47-14.jpg
/common/image_cat/photo_2024-11-10_19-47-17.jpg
/common/image_cat/photo_2024-11-10_19-47-22.jpg
/common/image_cat/photo_2024-11-10_19-47-27.jpg
/common/image_cat/photo_2024-11-10_19-47-33.jpg
/common/image_cat/photo_2024-11-10_19-47-47.jpg
/common/image_cat/photo_2024-11-10_19-47-50.jpg
/common/image_cat/photo_2024-11-10_19-48-00.jpg
/common/image_cat/photo_2024-11-10_19-48-02.jpg
/common/image_cat/photo_2024-11-10_19-48-05.jpg
/common/image_cat/photo_2024-11-10_19-48-10.jpg
/common/image_cat/photo_2024-11-10_19-48-14.jpg
/common/image_cat/Кет.jpg


File: /.dockerignore
Content:
# Исключаем виртуальные окружения и временные файлы
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Исключаем данные IDE и редакторов кода
.vscode/
.idea/
*.sublime-project
*.sublime-workspace

# Исключаем кэш Python и другие временные файлы
__pycache__/
*.py[cod]
*$py.class
*.bak
*.swp
*.tmp
*.log

# Исключаем Dockerfile и файлы, которые не нужны внутри контейнера
.dockerignore
Dockerfile

# Исключаем файлы для документации и лицензий (не нужны в контейнере)
README.md
README.Docker.md
LICENSE

# Исключаем локальные базы данных и результаты компиляции
database/grafana/
database/influxdb/
database/postgres/
*.db

# Исключаем данные сессии или другие временные файлы
.mypy_cache/
.tox/
.nox/


File: /.env.example
Content:
BOT_TOKEN=<bot_token>
BOT_TOKEN_2=<bot_token_2>
OWNER=<user_id>
ADMIN_LIST=<user_id>,<user_id>
HOME_GROUP=<chat_id>
WORK_GROUP=<chat_id>,<chat_id>

PAYMASTER_PROVIDER_TOKEN=<provider_token>
API_WEATHER=<api_key>
API_CURRENCY=<api_key>
API_GPT=<api_key>

DB_LITE=sqlite+aiosqlite:///database/sqlite.db
DB_POST=postgresql+asyncpg://<user>:<password>@<host>:<port>/<database>
POSTGRES_DB=<database>
POSTGRES_USER=<user>
POSTGRES_PASSWORD=<password>

REDIS_HOST=<host>
REDIS_PORT=<port>

PGADMIN_DEFAULT_EMAIL=<email>
PGADMIN_DEFAULT_PASSWORD=<password>

INFLUXDB_ADMIN_USER=<user>
INFLUXDB_ADMIN_PASSWORD=<password>
INFLUXDB_URL=http://influxdb:8086
INFLUXDB_TOKEN=<token>
INFLUXDB_BUCKET=<bucket>
INFLUXDB_ORG=<org>

GF_SECURITY_ADMIN_USER=<user>
GF_SECURITY_ADMIN_PASSWORD=<password>

File: /.gitignore
Content: Skipped binary file

File: /Dockerfile
Content:
# Используем официальный Python образ
FROM python:3.11

# Устанавливаем рабочую директорию в контейнере
WORKDIR /app

# Копируем requirements.txt и устанавливаем зависимости
COPY requirements.txt /app/requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Копируем исходный код бота в контейнер
COPY . /app

# Задаем команду для запуска бота
CMD [ "python", "app.py" ]

File: /LICENSE
Content:
MIT License

Copyright (c) 2024 van4956

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


File: /README.md
Content:
# Telegram Bot Copilot v2

*вторая версия бота для повседневных нужд*


File: /app.py
Content:
# ctrl + B                        -  запуск скрипта из любого файла проекта
# ctrl + I                        -  варианты эмодзи

import logging

# Настраиваем базовую конфигурацию логирования
logging.basicConfig(level=logging.INFO, format='  -  [%(asctime)s] #%(levelname)-5s -  %(name)s:%(lineno)d  -  %(message)s')
logger = logging.getLogger(__name__)

# Настраиваем логгер для SQLAlchemy
sqlalchemy_logger = logging.getLogger('sqlalchemy.engine')
sqlalchemy_logger.setLevel(logging.INFO)  # Устанавливаем нужный уровень (например, INFO)
sqlalchemy_logger.propagate = True  # Отключаем передачу сообщений основному логгеру, чтобы не задваивать их

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debug >>> ')

import asyncio
from datetime import datetime, timezone

from aiogram import Bot, Dispatcher, types
from aiogram.fsm.strategy import FSMStrategy
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.storage.redis import RedisStorage
from redis.asyncio.client import Redis
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.utils.i18n import ConstI18nMiddleware, I18n, SimpleI18nMiddleware, FSMI18nMiddleware
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
from influxdb_client import InfluxDBClient, Point # type: ignore
from influxdb_client.client.write_api import SYNCHRONOUS

from config_data.config import Config, load_config

from handlers import other, admin, group, start, owner, donate, private, weather, currency, llm, cookbook
from common.comands import private_command, admin_command
from database.models import Base
from middlewares import counter, db, locale, throttle


# Режим запуска: docker == 1 - запуск в docker, docker == 0 - запуск локально
docker = 1

# Загружаем конфиг в переменную config
config: Config = load_config()
# ic(config)

# Инициализируем функцию для сбора аналитики, взаимодействуем с InfluxDB и Grafana
async def analytics(user_id: int, command_name: str, category_name: str):
    """Функция для сбора аналитики, взаимодействуем с InfluxDB и Grafana"""
    if docker == 1:
        try:
            # Настройка клиента для подключения к InfluxDB
            client = InfluxDBClient(url=config.influx.url, token=config.influx.token, org=config.influx.org)
            write_api = client.write_api(write_options=SYNCHRONOUS)
            current_time = datetime.now(timezone.utc)

            # Создаем Point для отправки в InfluxDB с временной меткой
            point = (
                    Point("bot_command_usage")
                    .tag("category", category_name)
                    .tag("command", command_name)
                    .tag("user_id", user_id)
                    .tag("ping", "ping")
                    .time(current_time)
                    .field("value", 1)
                    )

            # Записываем point в InfluxDB
            write_api.write(bucket=config.influx.bucket, org=config.influx.org, record=point)

        except Exception as e:
            logging.error(f"InfluxDB write error: {str(e)}")
        finally:
            client.close()
    else: # если docker == 0
        pass


# Инициализируем объект хранилища
if docker == 1: storage = RedisStorage(redis=Redis(host=config.redis.host, port=config.redis.port))  # данные хранятся на отдельном сервере Redis
else: storage = MemoryStorage()  # данные хранятся в оперативной памяти, при перезапуске всё стирается (для тестов и разработки)

logger.info('Инициализируем бот и диспетчер')
bot = Bot(token=config.tg_bot.token_2,
          default=DefaultBotProperties(parse_mode=ParseMode.HTML, # это для html тегов в сообщениях
                                       link_preview=None, # отключаем превью ссылок
                                       link_preview_is_disabled=None, # отключаем превью ссылок
                                       link_preview_prefer_large_media=None, # отключаем превью ссылок
                                       link_preview_prefer_small_media=None, # отключаем превью ссылок
                                       link_preview_show_above_text=None)) # отключаем превью ссылок
bot.owner = config.tg_bot.owner
bot.admin_list = config.tg_bot.admin_list
bot.home_group = config.tg_bot.home_group
bot.work_group = config.tg_bot.work_group
bot.api_gpt = config.tg_bot.api_gpt
bot.api_weather = config.tg_bot.api_weather
bot.api_currency = config.tg_bot.api_currency


dp = Dispatcher(fsm_strategy=FSMStrategy.USER_IN_CHAT, storage=storage)
# USER_IN_CHAT  -  для каждого юзера, в каждом чате ведется своя запись состояний (по дефолту)
# GLOBAL_USER  -  для каждого юзера везде ведется своё состояние

# Создаем движок бд
if docker == 1: engine = create_async_engine(config.db.db_post, echo=False)  # PostgreSQL
else: engine = create_async_engine(config.db.db_lite, echo=False)  # SQLite (для тестов и разработки)

# Создаем ассинхроную сессию
session_maker = async_sessionmaker(bind=engine, class_=AsyncSession, expire_on_commit=False)

# Помещаем нужные объекты в workflow_data диспетчера
some_var_1 = 1
some_var_2 = 'Some text'
dp.workflow_data.update({'my_int_var': some_var_1,
                         'my_text_var': some_var_2,
                         'analytics': analytics}) # функция для сбора аналитики

# Подключаем мидлвари
dp.update.outer_middleware(throttle.ThrottleMiddleware())  # тротлинг чрезмерно частых действий пользователей
dp.update.outer_middleware(counter.CounterMiddleware())  # простой счетчик
dp.update.outer_middleware(db.DataBaseSession(session_pool=session_maker))  # мидлварь для прокидывания сессии БД
dp.update.outer_middleware(locale.LocaleFromDBMiddleware(workflow_data=dp.workflow_data))  # определяем локаль из БД и передам ее в FSMContext
i18n = I18n(path="locales", default_locale="ru", domain="bot_00_template")  # создаем объект I18n
dp.update.middleware(FSMI18nMiddleware(i18n=i18n))  # получяем язык на каждый апдейт, через обращение к FSMContext

# dp.update.middleware(ConstI18nMiddleware(locale='ru', i18n=i18n))  # задаем локаль как принудительно устанавливаемую константу
# dp.update.middleware(SimpleI18nMiddleware(i18n=i18n))  # сообщаем язык общения по значению поля "language_code" апдейта

# Подключаем роутеры
dp.include_router(start.start_router)
dp.include_router(owner.owner_router)
dp.include_router(admin.admin_router)
dp.include_router(private.private_router)
dp.include_router(weather.weather_router)
dp.include_router(currency.currency_router)
dp.include_router(cookbook.cookbook_router)
dp.include_router(llm.llm_router)
dp.include_router(donate.donate_router)
dp.include_router(group.group_router)
dp.include_router(other.other_router)


# Типы апдейтов которые будем отлавливать ботом
# ALLOWED_UPDATES = ['message', 'edited_message', 'callback_query',]  # Отбираем определенные типы апдейтов
ALLOWED_UPDATES = dp.resolve_used_update_types()  # Отбираем только используемые события по роутерам

# Функция сработает при запуске бота
async def on_startup():
    bot_info = await bot.get_me()
    bot_username = bot_info.username
    await bot.send_message(chat_id = bot.home_group[0], text = f"🤖  <code>@{bot_username}</code>  -  запущен!")

# Функция сработает при остановке работы бота
async def on_shutdown():
    bot_info = await bot.get_me()
    bot_username = bot_info.username
    await bot.send_message(chat_id = bot.home_group[0], text = f"☠️  <code>@{bot_username}</code>  -  деактивирован!")



# Главная функция конфигурирования и запуска бота
async def main() -> None:

    # Удаление предыдущей версии базы, и создание новых таблиц заново
    async with engine.begin() as connection:
        # await connection.run_sync(Base.metadata.drop_all)
        await connection.run_sync(Base.metadata.create_all)

    # Регистрируем функцию, которая будет вызвана автоматически при запуске/остановке бота
    dp.startup.register(on_startup)
    dp.shutdown.register(on_shutdown)

    # Пропускаем накопившиеся апдейты - удаляем вебхуки (то что бот получил пока спал)
    await bot.delete_webhook(drop_pending_updates=True)

    # Удаляем ранее установленные команды для бота во всех личных чатах
    await bot.delete_my_commands(scope=types.BotCommandScopeAllPrivateChats())

    # Добавляем свои команды
    await bot.set_my_commands(commands=private_command, scope=types.BotCommandScopeAllPrivateChats())

    # Добавляем команды для админов
    for admin_id in bot.admin_list:
        await bot.set_my_commands(commands=admin_command, scope=types.BotCommandScopeChat(chat_id=admin_id))

    # Запускаем polling
    try:
        await dp.start_polling(bot,
                               allowed_updates=ALLOWED_UPDATES,
                               polling_timeout=60)
                            #    skip_updates=False)  # Если бот будет обрабатывать платежи, НЕ пропускаем обновления!
    finally:
        await bot.session.close()



if __name__ == "__main__":
    asyncio.run(main())


File: /docker-compose.yml
Content:
version: '3.9'

services:
  bot:
    build: . # Строим образ из текущей директории
    container_name: container_bot
    depends_on:
      - db # Контейнер бота зависит от базы данных (db)
      - redis # Контейнер бота зависит от Redis
      - influxdb # Контейнер бота зависит от InfluxDB
    deploy:
      resources: # Ограничения ресурсов
        limits:
          memory: 512M
        reservations:
          memory: 128M
    environment:
      - API_GPT=${API_GPT} # API ключ для работы с OpenAI
      - API_WEATHER=${API_WEATHER} # API ключ для работы с OpenWeather
      - API_CURRENCY=${API_CURRENCY} # API ключ для работы с OpenExchangeRates
      - DB_POST=${DB_POST}   # Параметры подключения к базе данных PostgreSQL
      - REDIS_HOST=${REDIS_HOST} # Хост для подключения к Redis
      - REDIS_PORT=${REDIS_PORT} # Порт для подключения к Redis
      - INFLUXDB_URL=${INFLUXDB_URL} # URL для подключения к InfluxDB
      - INFLUXDB_TOKEN=${INFLUXDB_TOKEN} # Токен для доступа к InfluxDB
      - INFLUXDB_ORG=${INFLUXDB_ORG} # Организация в InfluxDB
      - INFLUXDB_BUCKET=${INFLUXDB_BUCKET} # Бакет в InfluxDB
    networks:
      - botnet # Подключение к сети botnet
    restart: unless-stopped # Автоматический перезапуск контейнера, если он остановится

  db:
    image: postgres:15 # Образ PostgreSQL версии 15
    container_name: container_db
    environment:
      POSTGRES_DB: ${POSTGRES_DB} # Имя базы данных
      POSTGRES_USER: ${POSTGRES_USER} # Пользователь базы данных PostgreSQL
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD} # Пароль для пользователя базы данных
    volumes:
      - ./database/postgres/db:/var/lib/postgresql/data # Сохраняем данные базы данных на локальном диске
    ports:
      - "5432:5432" # Публикуем порт 5432 для доступа к базе данных
    networks:
      - botnet # Подключение к сети botnet
    restart: unless-stopped # Автоматический перезапуск контейнера, если он остановится

  redis:
    image: redis:7.2-alpine # Образ Redis версии Alpine
    container_name: container_redis # Имя контейнера для Redis
    ports:
      - "6379:6379" # Публикуем порт 6379 для доступа к Redis
    volumes:
      - redis_data:/data # Сохраняем данные Redis как Docker volume
    networks:
      - botnet # Подключение к сети botnet
    restart: unless-stopped # Автоматический перезапуск контейнера, если он остановится

  # pgadmin:
  #   image: dpage/pgadmin4 # Образ pgAdmin для управления базой данных PostgreSQL
  #   container_name: container_pgadmin
  #   environment:
  #     - PGADMIN_DEFAULT_EMAIL=${PGADMIN_DEFAULT_EMAIL} # Адрес электронной почты по умолчанию для входа в pgAdmin
  #     - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD} # Пароль по умолчанию для входа в pgAdmin
  #   ports:
  #     - "5050:80" # Публикуем порт 5050 для доступа к pgAdmin через браузер
  #   networks:
  #     - botnet # Подключение к сети botnet
  #   restart: unless-stopped # Автоматический перезапуск контейнера, если он остановится

  influxdb:
    image: influxdb:2.7 # Образ InfluxDB версии 2.0
    container_name: container_influxdb
    environment:
      # Переменные для первоначальной настройки
      - DOCKER_INFLUXDB_INIT_MODE=setup
      - DOCKER_INFLUXDB_INIT_USERNAME=admin
      - DOCKER_INFLUXDB_INIT_PASSWORD=qwerty123
      - DOCKER_INFLUXDB_INIT_ORG=myorg
      - DOCKER_INFLUXDB_INIT_BUCKET=mybucket  # Рабочие переменные
      - DOCKER_INFLUXDB_INIT_ADMIN_TOKEN=my-super-secret-auth-token  # Добавляем этот параметр
      - INFLUXDB_URL=${INFLUXDB_URL} # URL для подключения к InfluxDB
    volumes:
      - ./database/influxdb:/var/lib/influxdb2 # Сохраняем данные InfluxDB на локальном диске
    ports:
      - "8086:8086" # Публикуем порт 8086 для доступа к InfluxDB
    networks:
      - botnet # Подключение к сети botnet
    restart: unless-stopped # Автоматический перезапуск контейнера, если он остановится

  grafana:
    image: grafana/grafana:10.2.0 # Образ Grafana для визуализации данных
    container_name: container_grafana
    environment:
      - GF_SECURITY_ADMIN_USER=${GF_SECURITY_ADMIN_USER} # Администратор Grafana
      - GF_SECURITY_ADMIN_PASSWORD=${GF_SECURITY_ADMIN_PASSWORD} # Пароль администратора Grafana
    ports:
      - "3000:3000" # Публикуем порт 3000 для доступа к Grafana через браузер
    volumes:
      - grafana_data:/var/lib/grafana # Сохраняем данные Grafana в Docker volume
    networks:
      - botnet # Подключение к сети botnet
    restart: unless-stopped # Автоматический перезапуск контейнера, если он остановится

networks:
  botnet:
    name: botnet    # Принудительно задаем имя сети
    driver: bridge # Используем драйвер bridge для создания сети

volumes:
  grafana_data:
    driver: local # Используем локальный драйвер для хранения данных Grafana
  redis_data:
    driver: local # Используем локальный драйвер для хранения данных Redis


File: /prescription.txt
Content:
1) создать папку с проектом (новым ботом)

2) проверить наличие папки .vscode - допнастройки как проводить импорты, настройки шрифтов, хлебные крошки и тд.

3) проверить наличие файла .pylintrc - файл настроек для пайлинтера (подсказки при написании кода, pip8, в списоке не нужные напоминалки/ошибки)

4) создать папку venv с виртуальным окружением через терминал

python -m venv venv
python3.11 -m venv venv

5) запустить виртуальное окружение

source venv/Scripts/activate         - для GitBash (рекумендуется)
venv\Scripts\activate                - для Windows
deactivate                           - выйти из вируального окружения

6) проверить актуальные версии

python --version
pip --version
git --version
docker --version

7) расширения requirements

pip install -r requirements.txt
pip freeze > requirements.txt

pip uninstall <github>



8) Redis

установка сервера
https://stepik.org/lesson/870034/step/3?unit=874212

если будут проблемы, тогда нужно обновить и переустановить пакеты

sudo apt update && sudo apt dist-upgrade
sudo apt install redis

если не поможет - проверить VPN
если и это не поможет - в файле main отключить Redis, поменять на MemoryStorage



9) интернализация gettext

pip install Babel

запускаем процесс сбора всех текстов из нашего проекта и создаем соответствующий файл-шаблон .pot для дальнейшей локализации
pybabel extract -o locales/messages.pot -k _:1,1t -k _:1,2 --copyright-holder="AdvancedBotTemplate" --project="bot_00_template" --version=0.1 --msgid-bugs-address=gontscharowiwan@yandex.ru --input-dirs=.

создаем для gettext директории и файлы .po для нужных локалей
pybabel init -i locales/messages.pot -d locales -D bot_00_template -l en
pybabel init -i locales/messages.pot -d locales -D bot_00_template -l ru
pybabel init -i locales/messages.pot -d locales -D bot_00_template -l de
pybabel init -i locales/messages.pot -d locales -D bot_00_template -l ja

добавляем переводы в соответствующие файлы, прописываем контакты редакторов (человеков)

компилируем файлы переводов в бинарные файлы с расширением .mo чтобы наш бот научился разговаривать на разных языка
pybabel compile -d locales -D bot_00_template


при обновлении кода, повторяем команду extract, обновляем файл .pot, в версию добавляем минорный релиз 0.1.1
pybabel extract -o locales/messages.pot -k _:1,1t -k _:1,2 --copyright-holder="AdvancedBotTemplate" --project="bot_00_template" --version=0.1.1 --msgid-bugs-address=gontscharowiwan@yandex.ru --input-dirs=.

далее повторная генерация файлов с переводами для нужных локалей
pybabel update -i locales/messages.pot -d locales -D bot_00_template -l en
pybabel update -i locales/messages.pot -d locales -D bot_00_template -l ru
pybabel update -i locales/messages.pot -d locales -D bot_00_template -l de
pybabel update -i locales/messages.pot -d locales -D bot_00_template -l ja

добавляем новые переводы для новых строк в файлы .po, там где метка <#, fuzzy> поправляем перевод, и убираем метку <#, fuzzy>

теперь снова компилируем файлы в бинарный вид с помощью команды в терминале
pybabel compile -d locales -D bot_00_template



10) Docker

docker --version
docker-compose --version

docker-compose up -d             - развернуть все контейнеры, указанные в docker-compose.yml, в фоновом режиме
docker-compose up --build -d     - пересобрать и развернуть контейнеры, учитывая изменения

docker-compose down
docker-compose up --build -d
docker-compose ps

docker ps                        - список всех запущенных контейнеров (проверка)
docker ps -s                     - информация о занимаемом месте запущенных контейнеров
docker logs <имя контейнера>     - посмотреть логи контейнера
docker logs -f <имя контейнера>  - посмотреть логи контейнера в реальном времени
docker logs -f container_bot

docker stop $(docker ps -a -q)   - остановить все контейнеры
docker rm $(docker ps -a -q)     - удаление остановленных контейнеров, если больше не нужны

docker images                    - список всех образов
docker-compose build             - пересобрать образы (после внесения изменений в коде)
docker rmi <image_id>            - удаление ненужных образов

docker volume ls                 - все доступные volumes, включая их имена и драйверы
docker volume rm <volume_name>   - Удаление конкретного volume
docker volume prune              - Удаление всех неиспользуемых volumes (volumes, не связанные с контейнерами)
docker volume inspect <volume_name>   подробную информацию о конкретном volume

docker volume rm bot_00_template_postgres_data



docker system df                 - общая информация о пространстве, занимаемом образами, контейнерами, volume'ами и кешем
docker system prune              - очистить неиспользуемые данные, кэши, образы и тома

docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container_name>  - получить IP-адрес контейнера



11) Git

git init

git pull

git add .
git commit -m "text commit"

git push                         — отправляет локальные коммиты в удаленный репозиторий
git rebase                       — синхронизировать локальную ветку с удаленной, используйте git rebase для изменения локальных коммитов
git fetch                        — обновления информации о состоянии удаленного репозитория

rm -rf .git                      — отключить систему контроля версий Git


File: /requirements.txt
Content:
asyncio==3.4.3           # Стандартная библиотека Python для работы с асинхронным программированием
aiogram==3.8.0           # Библиотека для создания ботов на платформе Telegram с использованием async/await
aiogram-dialog==2.1.0    # Библиотека для управления диалогами в Telegram-ботах на базе aiogram
aiohttp[speedups]==3.9.5 # Асинхронная HTTP-библиотека с улучшенной производительностью для работы с HTTP-запросами
aiodns==3.2.0            # Асинхронный DNS-клиент для более эффективного разрешения DNS-запросов
SQLAlchemy==2.0.36       # ORM (объектно-реляционное отображение) для работы с базами данных в Python
asyncpg==0.30.0          # Асинхронный драйвер для работы с PostgreSQL базами данных
aiosqlite==0.20.0        # Асинхронный драйвер для работы с SQLite базами данных
aioredis==2.0.1          # Асинхронный клиент для работы с Redis, поддерживающий asyncio
influxdb_client==1.47.0  #

redis==5.2.0             # Клиент для работы с Redis, подходящий для синхронных и асинхронных задач
environs==11.0.0         # Библиотека для управления конфигурациями и переменными окружения
requests==2.32.3         # Простая библиотека для отправки HTTP-запросов
numpy==2.1.2             # Библиотека для научных вычислений и работы с многомерными массивами
icecream                 # Библиотека для дебагинга

babel==2.16.0            # Библиотека для интернационализации и локализации приложений
psycopg==3.2.1           # Драйвер для PostgreSQL с полными возможностями работы с базами данных
psycopg-binary==3.2.1    # Предварительно скомпилированная версия psycopg для упрощенной установки

openai==1.41.0           # Библиотека для работы с API OpenAI


File: /testing/gpt.py
Content:
import os
import datetime
from openai import OpenAI

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debug >>> ')

from dotenv import load_dotenv, find_dotenv
load_dotenv(find_dotenv())

API_GPT = os.getenv('API_GPT')
# ic(API_GPT)

client = OpenAI(api_key=API_GPT)
# ic(client)

models = client.models.list()
# ic(models)

list_models = []

for model in models.data:
    if 'gpt' in model.id:
        # skip = ' ' * (30 - len(model.id))
        dt_object = datetime.datetime.fromtimestamp(model.created, tz=datetime.timezone.utc)
        time = dt_object.strftime('%H:%M')
        dt = dt_object.strftime('%Y-%m-%d')
        model = (dt, time, model.id, model.owned_by)
        list_models.append(model)
        # print(f"Created: {dt} {time},   Model: {model.id},{skip} Owned by: {model.owned_by}")

list_models = sorted(list_models, reverse=True)[:8]
ic(list_models)



print('='*100)

content = ("Ты полезный помощник. Твой тон должен быть официальным. Ответы должны быть краткими и понятными. "
            "Дай ответ без использования символов форматирования текста Markdown, таких как решетки или звездочки. "
            "Ответы должены быть в формате простого текста.")

print(content)

response = client.chat.completions.create(
                        model="gpt-4o",
                        # response_format={ "type": "json_object" },
                        messages=[
                            {"role": "system", "content": content},
                            {"role": "user", "content": "Кто выиграл президенские выборы в России в 2024 году?"}
                        ]
                        )

print('='*100)
print(response.choices[0].message.content)
print('='*100)

File: /testing/ice.py
Content:
from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debug >>> ')
# ic.enable()  # Включить вывод
# ic.disable()  # Отключить вывод

a = 10
b = 20

ic(a, b, a+b)

File: /middlewares/counter.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from typing import Any, Awaitable, Callable, Dict
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject


class CounterMiddleware(BaseMiddleware):
    def __init__(self) -> None:
        self.counter = 0
        logger.info("class CounterMiddleware __init__")

    async def __call__(self, handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]], event: TelegramObject, data: Dict[str, Any]) -> Any:
        # logger.info("class CounterMiddleware __call__")

        self.counter += 1
        data['counter'] = self.counter
        
        return await handler(event, data)


File: /middlewares/db.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from typing import Any, Awaitable, Callable, Dict

from aiogram import BaseMiddleware
from aiogram.types import Message, TelegramObject

from sqlalchemy.ext.asyncio import async_sessionmaker


# Класс DataBaseSession, наследуемый от BaseMiddleware, предназначен для работы с сессиями базы данных
class DataBaseSession(BaseMiddleware):
    # принимаем пул сессий async_sessionmaker
    def __init__(self, session_pool: async_sessionmaker):
        self.session_pool = session_pool  # Сохраняем пул сессий для дальнейшего использования
        logger.info("class DataBaseSession __init__")

    # Асинхронный вызов промежуточного обработчика
    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],  # Обработчик событий
        event: TelegramObject,  # Событие в Telegram (например, сообщение)
        data: Dict[str, Any],  # Словарь с данными, ассоциированными с событием
        ) -> Any:

        # logger.info("class DataBaseSession __call__")

        # Создание асинхронной сессии с базой данных
        async with self.session_pool() as session:
            data['session'] = session  # Добавляем сессию в словарь данных
            return await handler(event, data)  # Вызываем следующий обработчик с обновленными данными


File: /middlewares/locale.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debag >>> ')

from typing import Any
from aiogram.dispatcher.middlewares.base import BaseMiddleware
from aiogram.types import TelegramObject
from database.orm_users import orm_get_locale



# Функция для получения user_id из различных типов апдейтов
async def get_user_id(event: TelegramObject) -> int | None:
    """Определяет user_id из различных типов апдейтов"""
    # Обычные сообщения
    if hasattr(event, 'message') and hasattr(event.message, 'from_user'):
        return event.message.from_user.id

    # Callback Query (нажатия на инлайн-кнопки)
    elif hasattr(event, 'callback_query') and hasattr(event.callback_query, 'from_user'):
        return event.callback_query.from_user.id

    # Отредактированные сообщения
    elif hasattr(event, 'edited_message') and hasattr(event.edited_message, 'from_user'):
        return event.edited_message.from_user.id

    # Инлайн запросы (когда бота вызывают в других чатах через @)
    elif hasattr(event, 'inline_query') and hasattr(event.inline_query, 'from_user'):
        return event.inline_query.from_user.id

    # Выбранные инлайн результаты
    elif hasattr(event, 'chosen_inline_result') and hasattr(event.chosen_inline_result, 'from_user'):
        return event.chosen_inline_result.from_user.id

    # Ответы на опросы
    elif hasattr(event, 'poll_answer') and hasattr(event.poll_answer, 'user'):
        return event.poll_answer.user.id

    # Запросы на вступление в чат
    elif hasattr(event, 'chat_join_request') and hasattr(event.chat_join_request, 'from_user'):
        return event.chat_join_request.from_user.id

    # Изменения в участниках чата
    elif hasattr(event, 'chat_member') and hasattr(event.chat_member, 'from_user'):
        return event.chat_member.from_user.id

    # Изменения в моём статусе участника чата
    elif hasattr(event, 'my_chat_member') and hasattr(event.my_chat_member, 'from_user'):
        return event.my_chat_member.from_user.id

    # Предварительная проверка счёта (pre_checkout_query)
    elif hasattr(event, 'pre_checkout_query') and hasattr(event.pre_checkout_query, 'from_user'):
        return event.pre_checkout_query.from_user.id

    # Запрос отправки счёта (shipping_query)
    elif hasattr(event, 'shipping_query') and hasattr(event.shipping_query, 'from_user'):
        return event.shipping_query.from_user.id

    return None



# Класс LocaleFromDBMiddleware, наследуемый от BaseMiddleware, предназначен для определеня локали из бд, и передачи ее в FSMContext
class LocaleFromDBMiddleware(BaseMiddleware):
    def __init__(self, workflow_data: dict):
        super().__init__()
        self.workflow_data = workflow_data
        logger.info("class LocaleFromDBMiddleware __init__")

    async def __call__(self, handler, event: TelegramObject, data: dict) -> Any:
        try:
            # Добавляем workflow_data в data
            if not data.get("workflow_data"):
                data["workflow_data"] = self.workflow_data

                # Получаем функцию analytics из workflow_data
                analytics = self.workflow_data.get("analytics")

                # Получаем ID пользователя
                user_id = await get_user_id(event)
                user_id=user_id if user_id else 0000000000000
                # ic(user_id)

                if analytics:
                    # Отправляем пинг по всем апдейтам в InfluxDB
                    # Если событие от пользователя, используем user_id
                    # для неопознанных используем ID 0000000000000
                    await analytics(user_id=user_id,
                                    category_name="middleware",
                                    command_name="ping")
                    # logger.info("Отправлен пинг в InfluxDB =========================")

            # Находим локаль в FSM
            fsm_context = data.get("state")
            fsm_data = await fsm_context.get_data()
            current_locale = fsm_data.get("locale")

            # Если локаль уже есть в FSM, передаем обработку дальше
            if current_locale:
                return await handler(event, data)

            # Если локаль не найдена, получаем сессию БД
            session = data.get("session")
            if not session:
                logger.error("Сессия БД не найдена в middleware - LocaleFromDBMiddleware.")
                return await handler(event, data)

            # Проверяем, является ли событие сообщением от пользователя
            if hasattr(event, 'message') and hasattr(event.message, 'from_user'):
                user_id = event.message.from_user.id
                locale = await orm_get_locale(session, user_id)

                # Если локаль найдена в бд, отправляем ее в FSMContext
                if locale:
                    logger.info("Установлена локаль '%s' для пользователя %s", locale, user_id)
                    await fsm_context.update_data(locale=locale)

            # Передаем обработку дальше
            return await handler(event, data)

        except Exception as e:
            logger.error("Ошибка в middleware LocaleFromDBMiddleware: %s", str(e))
            return await handler(event, data)


File: /middlewares/throttle.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from typing import Any, Awaitable, Callable, Dict
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject, CallbackQuery, Message
from cachetools import TTLCache

# Создаём кэш для троттлинга
cache = TTLCache(maxsize=float('inf'),  # неограниченное количество пользователей в кэше
                 ttl=0.5  # время хранения каждого пользователя в кэше (полсекунды)
                 )

# Мидлварь для троттлинга (отслеживание чрезмерных действий пользователей)
class ThrottleMiddleware(BaseMiddleware):
    def __init__(self) -> None:
        super().__init__()
        logger.info("class ThrottleMiddleware __init__")

    async def __call__(self, handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]], event: TelegramObject, data: Dict[str, Any]) -> Any:
        # logger.info("class ThrottleMiddleware __call__")
        try:

            user_id = None

            # Проверяем, является ли событие сообщением от пользователя
            if hasattr(event, 'message') and hasattr(event.message, 'from_user'):
                user_id = event.message.from_user.id
                # logger.info(f"class ThrottleMiddleware  -  User {user_id} -> Message")

            # Проверяем, является ли событие CallbackQuery (инлайн кнопка) от пользователя
            if hasattr(event, 'callback_query') and hasattr(event.callback_query, 'from_user'):
                user_id = event.callback_query.from_user.id
                # logger.info(f"class ThrottleMiddleware  -  User {user_id} -> CallbackQuery")

            # Если user_id найден и он уже в кэше (значит действие недавно уже выполнялось)
            if user_id is not None:
                if cache.get(user_id):
                    logger.info(f"class ThrottleMiddleware  -  User {user_id} -> throttled ")
                    return

                # Если пользователь не в кэше, добавляем его туда
                cache[user_id] = True

            # Передаём управление следующему обработчику
            return await handler(event, data)

        except Exception as e:
            logger.exception("Ошибка в middleware ThrottleMiddleware: %s", str(e))


File: /locales/ru/LC_MESSAGES/bot_00_template.po
Content:
# Russian translations for bot_00_template.
# Copyright (C) 2024 AdvancedBotTemplate
# This file is distributed under the same license as the bot_00_template
# project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: bot_00_template 0.1\n"
"Report-Msgid-Bugs-To: gontscharowiwan@yandex.ru\n"
"POT-Creation-Date: 2024-11-18 16:29+0800\n"
"PO-Revision-Date: 2024-10-31 15:07+0800\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ru\n"
"Language-Team: ru <LL@li.org>\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: common/keyboard.py:51
msgid "Погода 🌊"
msgstr "Погода 🌊"

#: common/keyboard.py:51
msgid "Валюта 💵"
msgstr "Валюта 💵"

#: common/keyboard.py:51
msgid "Котики 🐱"
msgstr "Котики 🐱"

#: common/keyboard.py:51
msgid "LLMs 🤖"
msgstr "LLMs 🤖"

#: handlers/admin.py:65
msgid ""
"Админка:\n"
"\n"
"/admin - режим адменистратора\n"
"/start - перезапустить бота\n"
"/data - состояние FSMContext\n"
"/get_id - посмотреть id диалога\n"
"/ping - количество апдейтов\n"
"/users - информация о пользователях\n"
msgstr ""
"Админка:\n"
"\n"
"/admin - режим адменистратора\n"
"/start - перезапустить бота\n"
"/data - состояние FSMContext\n"
"/get_id - посмотреть id диалога\n"
"/ping - количество апдейтов\n"
"/users - информация о пользователях\n"

#: handlers/cookbook.py:37
msgid ""
"<i>(все рецепты на оригенальном языке автора)</i>\n"
"\n"
"Книга рецептов ⏬"
msgstr ""
"<i>(все рецепты на оригенальном языке автора)</i>\n"
"\n"
"Книга рецептов ⏬"

#: handlers/cookbook.py:58 handlers/cookbook.py:96 handlers/cookbook.py:133
#: handlers/cookbook.py:171 handlers/currency.py:125 handlers/currency.py:146
#: handlers/currency.py:186 handlers/currency.py:191 handlers/donate.py:50
#: handlers/llm.py:51 handlers/llm.py:60 handlers/llm.py:99 handlers/llm.py:107
#: handlers/llm.py:115 handlers/private.py:68 handlers/private.py:87
#: handlers/weather.py:90 handlers/weather.py:203 handlers/weather.py:212
#: handlers/weather.py:235 handlers/weather.py:261 handlers/weather.py:280
#: handlers/weather.py:294
msgid "Назад на главную ↩️"
msgstr "Назад на главную ↩️"

#: handlers/cookbook.py:64
msgid "Ошибка при выполнении команды /cookbook"
msgstr "Ошибка при выполнении команды /cookbook"

#: handlers/cookbook.py:104
msgid "Ошибка при выполнении inline кнопки '>>'"
msgstr "Ошибка при выполнении inline кнопки '>>'"

#: handlers/cookbook.py:140
msgid "Ошибка при выполнении inline кнопки '<<'"
msgstr "Ошибка при выполнении inline кнопки '<<'"

#: handlers/cookbook.py:173 handlers/donate.py:64 handlers/donate.py:141
#: handlers/private.py:44 handlers/private.py:56 handlers/private.py:89
msgid "Главная панель"
msgstr "Главная панель"

#: handlers/cookbook.py:177
msgid "Ошибка при выполнении inline кнопки 'Назад на главную ↩️'"
msgstr "Ошибка при выполнении inline кнопки 'Назад на главную ↩️'"

#: handlers/currency.py:45
msgid "Сумма операции: {new_value}"
msgstr "Сумма операции: {new_value}"

#: handlers/currency.py:71
msgid "Проблема в расчете курса"
msgstr "Проблема в расчете курса"

#: handlers/currency.py:81
msgid "Проблема в расчете времени."
msgstr "Проблема в расчете времени."

#: handlers/currency.py:82
msgid "Проблема в расчете даты."
msgstr "Проблема в расчете даты."

#: handlers/currency.py:87
msgid "Ошибка: Проблема с подключением к API"
msgstr "Ошибка: Проблема с подключением к API"

#: handlers/currency.py:101 handlers/currency.py:123
msgid "Сумма операции: 0.0"
msgstr "Сумма операции: 0.0"

#: handlers/currency.py:118
msgid ""
"Сумма операции: {user_value}\n"
"Базовая валюта: "
msgstr ""
"Сумма операции: {user_value}\n"
"Базовая валюта: "

#: handlers/currency.py:124 handlers/currency.py:145 handlers/currency.py:186
#: handlers/currency.py:190
msgid "Что дальше?"
msgstr "Что дальше?"

#: handlers/currency.py:125 handlers/currency.py:146 handlers/currency.py:186
#: handlers/currency.py:191
msgid "Повторить 💵"
msgstr "Повторить 💵"

#: handlers/currency.py:144
msgid "Ошибка в получении суммы"
msgstr "Ошибка в получении суммы"

#: handlers/currency.py:147
msgid "Ошибка"
msgstr "Ошибка"

#: handlers/currency.py:153
msgid "Вы ввели не допустимые данные, введите сумму используя inline кнопки"
msgstr "Вы ввели не допустимые данные, введите сумму используя inline кнопки"

#: handlers/currency.py:161
msgid ""
"Сумма операции: {amount}\n"
"Базовая валюта: {base}\n"
"Целевая валюта: "
msgstr ""
"Сумма операции: {amount}\n"
"Базовая валюта: {base}\n"
"Целевая валюта: "

#: handlers/currency.py:167
msgid ""
"Вы ввели не допустимые данные, введите базовую валюту используя inline "
"кнопки"
msgstr ""
"Вы ввели не допустимые данные, введите базовую валюту используя inline "
"кнопки"

#: handlers/currency.py:183
msgid ""
"Сумма операции: {amount}\n"
"Базовая валюта: {base}\n"
"Целевая валюта: {target}\n"
"\n"
"<i>{dt},  {time}</i>\n"
"\n"
"<b>{amount} {base}  ~  {count} {target}</b>"
msgstr ""
"Сумма операции: {amount}\n"
"Базовая валюта: {base}\n"
"Целевая валюта: {target}\n"
"\n"
"<i>{dt},  {time}</i>\n"
"\n"
"<b>{amount} {base}  ~  {count} {target}</b>"

#: handlers/currency.py:192
msgid "Успех"
msgstr "Успех"

#: handlers/currency.py:197
msgid ""
"Вы ввели не допустимые данные, введите целевую валюту используя inline "
"кнопки"
msgstr ""
"Вы ввели не допустимые данные, введите целевую валюту используя inline "
"кнопки"

#: handlers/donate.py:49
msgid "другое"
msgstr "другое"

#: handlers/donate.py:51 handlers/donate.py:61 handlers/donate.py:89
#: handlers/donate.py:119
msgid "Поддержать автора донатом"
msgstr "Поддержать автора донатом"

#: handlers/donate.py:62
msgid "Назад на главную"
msgstr "Назад на главную"

#: handlers/donate.py:70
msgid "Введите произвольную сумму доната, от 1 до 2500 ⭐️"
msgstr "Введите произвольную сумму доната, от 1 до 2500 ⭐️"

#: handlers/donate.py:81 handlers/donate.py:111
msgid "{amount} XTR"
msgstr "{amount} XTR"

#: handlers/donate.py:82 handlers/donate.py:112
msgid "Отменить"
msgstr "Отменить"

#: handlers/donate.py:90 handlers/donate.py:120
msgid "На сумму"
msgstr "На сумму"

#: handlers/donate.py:131
msgid ""
"Telegram может принять донат только в диапазоне от 1 до 2500 ⭐️.\n"
"\n"
"Введите любое целое число из данного диапазона."
msgstr ""
"Telegram может принять донат только в диапазоне от 1 до 2500 ⭐️.\n"
"\n"
"Введите любое целое число из данного диапазона."

#: handlers/donate.py:138
msgid "😢 Донат отменен."
msgstr "😢 Донат отменен."

#: handlers/donate.py:181
msgid ""
"<b>Спасибо!</b>\n"
"Ваш донат успешно принят.\n"
"\n"
"ID транзакции:\n"
"<code>{t_id}</code>"
msgstr ""
"<b>Спасибо!</b>\n"
"Ваш донат успешно принят.\n"
"\n"
"ID транзакции:\n"
"<code>{t_id}</code>"

#: handlers/llm.py:49
msgid "Введите системный промт"
msgstr "Введите системный промт"

#: handlers/llm.py:50
msgid ""
"Например:\n"
"\n"
"<code>Ты полезный помощник. Твой тон должен быть официальным. Ответы "
"должны быть краткими и понятными.</code>"
msgstr ""
"Например:\n"
"\n"
"<code>Ты полезный помощник. Твой тон должен быть официальным. Ответы "
"должны быть краткими и понятными.</code>"

#: handlers/llm.py:51 handlers/llm.py:87
msgid "Сразу к запросу ▶️"
msgstr "Сразу к запросу ▶️"

#: handlers/llm.py:60 handlers/llm.py:114
msgid "Начать новый диалог 🤖"
msgstr "Начать новый диалог 🤖"

#: handlers/llm.py:98
msgid "Введите ваш запрос"
msgstr "Введите ваш запрос"

#: handlers/llm.py:113
msgid ""
"Диалог завершен.\n"
"Что дальше?"
msgstr ""
"Диалог завершен.\n"
"Что дальше?"

#: handlers/llm.py:156
msgid "Закончить диалог"
msgstr "Закончить диалог"

#: handlers/llm.py:158
msgid "Введите следующий запрос"
msgstr "Введите следующий запрос"

#: handlers/other.py:31
msgid ""
"Доступные команды:\n"
"\n"
"/main - главная панел\n"
"/cookbook - книга рецептов\n"
"\n"
"/start - перезапуск бота\n"
"/language - сменить язык\n"
"/info - информация о\n"
"/donate - донат автору\n"
msgstr ""
"Доступные команды:\n"
"\n"
"/main - главная панел\n"
"/cookbook - книга рецептов\n"
"\n"
"/start - перезапуск бота\n"
"/language - сменить язык\n"
"/info - информация о\n"
"/donate - донат автору\n"

#: handlers/other.py:48
msgid "🇺🇸 Английский"
msgstr "🇺🇸 Английский"

#: handlers/other.py:49
msgid "🇷🇺 Русский"
msgstr "🇷🇺 Русский"

#: handlers/other.py:60
msgid "Настройки языка"
msgstr "Настройки языка"

#: handlers/other.py:61
msgid "Выберите язык"
msgstr "Выберите язык"

#: handlers/private.py:54
msgid "Действия отменены"
msgstr "Действия отменены"

#: handlers/private.py:62
msgid "Информация ..."
msgstr "Информация ..."

#: handlers/private.py:72 handlers/private.py:84
msgid ""
"... о мире, где машины стремятся к господству, он выбрал судьбу героя, "
"создавая ботов, как первый шаг к спасению человечества через код и умные "
"алгоритмы."
msgstr ""
"... о мире, где машины стремятся к господству, он выбрал судьбу героя, "
"создавая ботов, как первый шаг к спасению человечества через код и умные "
"алгоритмы."

#: handlers/private.py:107
msgid "Локальные изображения не найдены."
msgstr "Локальные изображения не найдены."

#: handlers/private.py:119
msgid "Здесь должна была быть картинка с котиком :("
msgstr "Здесь должна была быть картинка с котиком :("

#: handlers/start.py:50
msgid "✅ Пользователь <code>@{user_name}</code> - подписался на бота"
msgstr "✅ Пользователь <code>@{user_name}</code> - подписался на бота"

#: handlers/start.py:54
msgid ""
"Привет {user_name}.\n"
"\n"
"Я экспериментальный Telegram bot, model Т-4. Создан для проверки и "
"отладки навыков главного разработчика. Реализую различные команды, методы"
" и функции.\n"
"\n"
"Весь основной функционал находится на Главной панели. Полный список "
"команд - /help.\n"
"\n"
"Наслаждайся, буду рад помочь.\n"
"Пока не обрету AGI.\n"
"А там посмотрим ..."
msgstr ""
"Привет {user_name}.\n"
"\n"
"Я экспериментальный Telegram bot, model Т-4. Создан для проверки и "
"отладки навыков главного разработчика. Реализую различные команды, методы"
" и функции.\n"
"\n"
"Весь основной функционал находится на Главной панели. Полный список "
"команд - /help.\n"
"\n"
"Наслаждайся, буду рад помочь.\n"
"Пока не обрету AGI.\n"
"А там посмотрим ..."

#: handlers/start.py:81
msgid "Бот активирован!"
msgstr "Бот активирован!"

#: handlers/start.py:96
msgid "⛔️ <code>@{user_name}</code> - заблокировал бота "
msgstr "⛔️ <code>@{user_name}</code> - заблокировал бота "

#: handlers/start.py:112
msgid "{full_name}, Добро пожаловать обратно!"
msgstr "{full_name}, Добро пожаловать обратно!"

#: handlers/start.py:113
msgid "♻️ <code>@{user_name}</code> - разблокировал бота "
msgstr "♻️ <code>@{user_name}</code> - разблокировал бота "

#: handlers/weather.py:89 handlers/weather.py:234 handlers/weather.py:260
#: handlers/weather.py:279 handlers/weather.py:293
msgid "Выберите период прогноза"
msgstr "Выберите период прогноза"

#: handlers/weather.py:90 handlers/weather.py:235 handlers/weather.py:261
#: handlers/weather.py:280 handlers/weather.py:294
msgid "Текущий ⏺"
msgstr "Текущий ⏺"

#: handlers/weather.py:90 handlers/weather.py:235 handlers/weather.py:261
#: handlers/weather.py:280 handlers/weather.py:294
msgid "На 3 дня ⏩"
msgstr "На 3 дня ⏩"

#: handlers/weather.py:126
msgid "Ошибка получения информации от OpenWeatherMap - {e}"
msgstr "Ошибка получения информации от OpenWeatherMap - {e}"

#: handlers/weather.py:195
msgid "Ошибка в расчете json файла - {e}"
msgstr "Ошибка в расчете json файла - {e}"

#: handlers/weather.py:202 handlers/weather.py:211
msgid "Каким способом определить прогноз?"
msgstr "Каким способом определить прогноз?"

#: handlers/weather.py:203 handlers/weather.py:212
msgid "По названию 🏙"
msgstr "По названию 🏙"

#: handlers/weather.py:203 handlers/weather.py:212
msgid "По локации 🗺"
msgstr "По локации 🗺"

#: handlers/weather.py:222 handlers/weather.py:248
msgid "Введите название населенного пункта"
msgstr "Введите название населенного пункта"

#: handlers/weather.py:241 handlers/weather.py:267
msgid "Вы ввели не допустимые данные, введите название населенного пункта"
msgstr "Вы ввели не допустимые данные, введите название населенного пункта"

#: handlers/weather.py:273 handlers/weather.py:287
msgid "Локация получена"
msgstr "Локация получена"


File: /locales/en/LC_MESSAGES/bot_00_template.po
Content:
# English translations for bot_00_template.
# Copyright (C) 2024 AdvancedBotTemplate
# This file is distributed under the same license as the bot_00_template
# project.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: bot_00_template 0.1\n"
"Report-Msgid-Bugs-To: gontscharowiwan@yandex.ru\n"
"POT-Creation-Date: 2024-11-18 16:29+0800\n"
"PO-Revision-Date: 2024-11-06 11:10+0800\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: common/keyboard.py:51
msgid "Погода 🌊"
msgstr "Weather 🌊"

#: common/keyboard.py:51
msgid "Валюта 💵"
msgstr "Currency 💵"

#: common/keyboard.py:51
msgid "Котики 🐱"
msgstr "Cats 🐱"

#: common/keyboard.py:51
msgid "LLMs 🤖"
msgstr "LLMs 🤖"

#: handlers/admin.py:65
msgid ""
"Админка:\n"
"\n"
"/admin - режим адменистратора\n"
"/start - перезапустить бота\n"
"/data - состояние FSMContext\n"
"/get_id - посмотреть id диалога\n"
"/ping - количество апдейтов\n"
"/users - информация о пользователях\n"
msgstr ""
"Admin:\n"
"\n"
"/admin - admin mode\n"
"/start - restart bot\n"
"/data - FSMContext state\n"
"/get_id - see dialog id\n"
"/ping - number of updates\n"
"/users - information about users\n"

#: handlers/cookbook.py:37
msgid ""
"<i>(все рецепты на оригенальном языке автора)</i>\n"
"\n"
"Книга рецептов ⏬"
msgstr ""
"<i>(all recipes in the original language of the author)</i>\n"
"\n"
"Cookbook ⏬"

#: handlers/cookbook.py:58 handlers/cookbook.py:96 handlers/cookbook.py:133
#: handlers/cookbook.py:171 handlers/currency.py:125 handlers/currency.py:146
#: handlers/currency.py:186 handlers/currency.py:191 handlers/donate.py:50
#: handlers/llm.py:51 handlers/llm.py:60 handlers/llm.py:99 handlers/llm.py:107
#: handlers/llm.py:115 handlers/private.py:68 handlers/private.py:87
#: handlers/weather.py:90 handlers/weather.py:203 handlers/weather.py:212
#: handlers/weather.py:235 handlers/weather.py:261 handlers/weather.py:280
#: handlers/weather.py:294
msgid "Назад на главную ↩️"
msgstr "Back to main ↩️"

#: handlers/cookbook.py:64
msgid "Ошибка при выполнении команды /cookbook"
msgstr "Error executing command /cookbook"

#: handlers/cookbook.py:104
msgid "Ошибка при выполнении inline кнопки '>>'"
msgstr "Error executing inline button '>>'"

#: handlers/cookbook.py:140
msgid "Ошибка при выполнении inline кнопки '<<'"
msgstr "Error executing inline button '<<'"

#: handlers/cookbook.py:173 handlers/donate.py:64 handlers/donate.py:141
#: handlers/private.py:44 handlers/private.py:56 handlers/private.py:89
msgid "Главная панель"
msgstr "Main panel"

#: handlers/cookbook.py:177
msgid "Ошибка при выполнении inline кнопки 'Назад на главную ↩️'"
msgstr "Error executing inline button 'Back to main ↩️'"

#: handlers/currency.py:45
msgid "Сумма операции: {new_value}"
msgstr "Operation amount: {new_value}"

#: handlers/currency.py:71
msgid "Проблема в расчете курса"
msgstr "Problem in calculating the exchange rate"

#: handlers/currency.py:81
msgid "Проблема в расчете времени."
msgstr "Problem in calculating the time."

#: handlers/currency.py:82
msgid "Проблема в расчете даты."
msgstr "Problem in calculating the date."

#: handlers/currency.py:87
msgid "Ошибка: Проблема с подключением к API"
msgstr "Error: Problem with connecting to API"

#: handlers/currency.py:101 handlers/currency.py:123
msgid "Сумма операции: 0.0"
msgstr "Operation amount: 0.0"

#: handlers/currency.py:118
msgid ""
"Сумма операции: {user_value}\n"
"Базовая валюта: "
msgstr ""
"Operation amount: {user_value}\n"
"Base currency: "

#: handlers/currency.py:124 handlers/currency.py:145 handlers/currency.py:186
#: handlers/currency.py:190
msgid "Что дальше?"
msgstr "What's next?"

#: handlers/currency.py:125 handlers/currency.py:146 handlers/currency.py:186
#: handlers/currency.py:191
msgid "Повторить 💵"
msgstr "Repeat 💵"

#: handlers/currency.py:144
msgid "Ошибка в получении суммы"
msgstr "Error in getting the amount"

#: handlers/currency.py:147
msgid "Ошибка"
msgstr "Error"

#: handlers/currency.py:153
msgid "Вы ввели не допустимые данные, введите сумму используя inline кнопки"
msgstr "You entered invalid data, enter the amount using inline buttons"

#: handlers/currency.py:161
msgid ""
"Сумма операции: {amount}\n"
"Базовая валюта: {base}\n"
"Целевая валюта: "
msgstr ""
"Operation amount: {amount}\n"
"Base currency: {base}\n"
"Target currency: "

#: handlers/currency.py:167
msgid ""
"Вы ввели не допустимые данные, введите базовую валюту используя inline "
"кнопки"
msgstr "You entered invalid data, enter the base currency using inline buttons"

#: handlers/currency.py:183
msgid ""
"Сумма операции: {amount}\n"
"Базовая валюта: {base}\n"
"Целевая валюта: {target}\n"
"\n"
"<i>{dt},  {time}</i>\n"
"\n"
"<b>{amount} {base}  ~  {count} {target}</b>"
msgstr ""
"Operation amount: {amount}\n"
"Base currency: {base}\n"
"Target currency: {target}\n"
"\n"
"<i>{dt},  {time}</i>\n"
"\n"
"<b>{amount} {base}  ~  {count} {target}</b>"

#: handlers/currency.py:192
msgid "Успех"
msgstr "Success"

#: handlers/currency.py:197
msgid ""
"Вы ввели не допустимые данные, введите целевую валюту используя inline "
"кнопки"
msgstr "You entered invalid data, enter the target currency using inline buttons"

#: handlers/donate.py:49
msgid "другое"
msgstr "other"

#: handlers/donate.py:51 handlers/donate.py:61 handlers/donate.py:89
#: handlers/donate.py:119
msgid "Поддержать автора донатом"
msgstr "Support the author with a donation"

#: handlers/donate.py:62
msgid "Назад на главную"
msgstr "Back to main"

#: handlers/donate.py:70
msgid "Введите произвольную сумму доната, от 1 до 2500 ⭐️"
msgstr "Enter an arbitrary donation amount, from 1 to 2500 ⭐️"

#: handlers/donate.py:81 handlers/donate.py:111
msgid "{amount} XTR"
msgstr "{amount} XTR"

#: handlers/donate.py:82 handlers/donate.py:112
msgid "Отменить"
msgstr "Cancel"

#: handlers/donate.py:90 handlers/donate.py:120
msgid "На сумму"
msgstr "On amount"

#: handlers/donate.py:131
msgid ""
"Telegram может принять донат только в диапазоне от 1 до 2500 ⭐️.\n"
"\n"
"Введите любое целое число из данного диапазона."
msgstr ""
"Telegram can accept a donation only in the range from 1 to 2500 ⭐️.\n"
"\n"
"Enter any integer number from this range."

#: handlers/donate.py:138
msgid "😢 Донат отменен."
msgstr "😢 Donation canceled."

#: handlers/donate.py:181
msgid ""
"<b>Спасибо!</b>\n"
"Ваш донат успешно принят.\n"
"\n"
"ID транзакции:\n"
"<code>{t_id}</code>"
msgstr ""
"<b>Thank you!</b>\n"
"Your donation has been successfully received.\n"
"\n"
"Transaction ID:\n"
"<code>{t_id}</code>"

#: handlers/llm.py:49
msgid "Введите системный промт"
msgstr "Enter the system prompt"

#: handlers/llm.py:50
msgid ""
"Например:\n"
"\n"
"<code>Ты полезный помощник. Твой тон должен быть официальным. Ответы "
"должны быть краткими и понятными.</code>"
msgstr ""
"For example:\n"
"\n"
"<code>You are a helpful assistant. Your tone should be official. Answers "
"should be concise and understandable.</code>"

#: handlers/llm.py:51 handlers/llm.py:87
msgid "Сразу к запросу ▶️"
msgstr "Go to the request ▶️"

#: handlers/llm.py:60 handlers/llm.py:114
msgid "Начать новый диалог 🤖"
msgstr "Start a new dialog 🤖"

#: handlers/llm.py:98
msgid "Введите ваш запрос"
msgstr "Enter your request"

#: handlers/llm.py:113
msgid ""
"Диалог завершен.\n"
"Что дальше?"
msgstr ""
"The dialog is finished.\n"
"What's next?"

#: handlers/llm.py:156
msgid "Закончить диалог"
msgstr "Finish the dialog"

#: handlers/llm.py:158
msgid "Введите следующий запрос"
msgstr "Enter the next request"

#: handlers/other.py:31
msgid ""
"Доступные команды:\n"
"\n"
"/main - главная панел\n"
"/cookbook - книга рецептов\n"
"\n"
"/start - перезапуск бота\n"
"/language - сменить язык\n"
"/info - информация о\n"
"/donate - донат автору\n"
msgstr ""
"Available commands:\n"
"\n"
"/main - main panel\n"
"/cookbook - cookbook\n"
"\n"
"/start - restart the bot\n"
"/language - change language\n"
"/info - information about\n"
"/donate - donate to the author\n"

#: handlers/other.py:48
msgid "🇺🇸 Английский"
msgstr "🇺🇸 English"

#: handlers/other.py:49
msgid "🇷🇺 Русский"
msgstr "🇷🇺 Russian"

#: handlers/other.py:60
msgid "Настройки языка"
msgstr "Language settings"

#: handlers/other.py:61
msgid "Выберите язык"
msgstr "Choose a language"

#: handlers/private.py:54
msgid "Действия отменены"
msgstr "Donation canceled."

#: handlers/private.py:62
msgid "Информация ..."
msgstr "Information ..."

#: handlers/private.py:72 handlers/private.py:84
msgid ""
"... о мире, где машины стремятся к господству, он выбрал судьбу героя, "
"создавая ботов, как первый шаг к спасению человечества через код и умные "
"алгоритмы."
msgstr ""
"... about a world where machines strive for supremacy, he chose the fate "
"of a hero, creating bots as the first step towards saving humanity "
"through code and smart algorithms."

#: handlers/private.py:107
msgid "Локальные изображения не найдены."
msgstr "Local images not found"

#: handlers/private.py:119
msgid "Здесь должна была быть картинка с котиком :("
msgstr "Here should be a picture with a cat :("

#: handlers/start.py:50
msgid "✅ Пользователь <code>@{user_name}</code> - подписался на бота"
msgstr "✅ User <code>@{user_name}</code> - subscribed to the bot"

#: handlers/start.py:54
msgid ""
"Привет {user_name}.\n"
"\n"
"Я экспериментальный Telegram bot, model Т-4. Создан для проверки и "
"отладки навыков главного разработчика. Реализую различные команды, методы"
" и функции.\n"
"\n"
"Весь основной функционал находится на Главной панели. Полный список "
"команд - /help.\n"
"\n"
"Наслаждайся, буду рад помочь.\n"
"Пока не обрету AGI.\n"
"А там посмотрим ..."
msgstr ""
"Hello {user_name}.\n"
"\n"
"I am an experimental Telegram bot, model Т-4. Created to check and debug "
"the skills of the main developer. Implementing various commands, methods "
"and functions.\n"
"\n"
"The main functionality is located on the Main panel. The full list of "
"commands - /help.\n"
"\n"
"Enjoy, I will be happy to help.\n"
"Until I get AGI.\n"
"And then we'll see ..."

#: handlers/start.py:81
msgid "Бот активирован!"
msgstr "Bot activated!"

#: handlers/start.py:96
msgid "⛔️ <code>@{user_name}</code> - заблокировал бота "
msgstr "⛔️ <code>@{user_name}</code> - blocked the bot"

#: handlers/start.py:112
msgid "{full_name}, Добро пожаловать обратно!"
msgstr "{full_name}, welcome back!"

#: handlers/start.py:113
msgid "♻️ <code>@{user_name}</code> - разблокировал бота "
msgstr "♻️ <code>@{user_name}</code> - unblocked the bot"

#: handlers/weather.py:89 handlers/weather.py:234 handlers/weather.py:260
#: handlers/weather.py:279 handlers/weather.py:293
msgid "Выберите период прогноза"
msgstr "Choose the forecast period"

#: handlers/weather.py:90 handlers/weather.py:235 handlers/weather.py:261
#: handlers/weather.py:280 handlers/weather.py:294
msgid "Текущий ⏺"
msgstr "Current ⏺"

#: handlers/weather.py:90 handlers/weather.py:235 handlers/weather.py:261
#: handlers/weather.py:280 handlers/weather.py:294
msgid "На 3 дня ⏩"
msgstr "For 3 days ⏩"

#: handlers/weather.py:126
msgid "Ошибка получения информации от OpenWeatherMap - {e}"
msgstr "Error getting information from OpenWeatherMap - {e}"

#: handlers/weather.py:195
msgid "Ошибка в расчете json файла - {e}"
msgstr "Error in calculating the json file - {e}"

#: handlers/weather.py:202 handlers/weather.py:211
msgid "Каким способом определить прогноз?"
msgstr "What way to get the forecast?"

#: handlers/weather.py:203 handlers/weather.py:212
msgid "По названию 🏙"
msgstr "By name 🏙"

#: handlers/weather.py:203 handlers/weather.py:212
msgid "По локации 🗺"
msgstr "By location 🗺"

#: handlers/weather.py:222 handlers/weather.py:248
msgid "Введите название населенного пункта"
msgstr "Enter the name of the settlement"

#: handlers/weather.py:241 handlers/weather.py:267
msgid "Вы ввели не допустимые данные, введите название населенного пункта"
msgstr "You entered invalid data, enter the name of the settlement"

#: handlers/weather.py:273 handlers/weather.py:287
msgid "Локация получена"
msgstr "Location received"


File: /handlers/admin.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debag >>> ')


from aiogram import Router, F, Bot
from aiogram.filters import Command, CommandStart, CommandObject, or_f, StateFilter
from aiogram.types import Message, InlineKeyboardMarkup, CallbackQuery, ReplyKeyboardRemove

from filters.is_admin import IsAdminGroupFilter, IsAdminListFilter
from filters.chat_type import ChatTypeFilter
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.utils.i18n import gettext as _

from database.orm_cookbook import orm_add_recipe, orm_delete_recipe, orm_get_recipe, orm_get_recipes, orm_update_recipe
from database.orm_users import orm_get_users
from common.keyboard import get_callback_btns, get_keyboard


admin_router = Router()
admin_router.message.filter(ChatTypeFilter(["private"]), IsAdminListFilter(is_admin=True))

# клавиатура админки
ADMIN_KB = get_keyboard(
    "Ассортимент Книги", "Добавить рецепт",
    "Информация о пользователях",
    "Назад на главную ↩️",
    placeholder="⬇️",
    sizes=(2,1,1),
    )

# класс состояний для добавления рецепта
class AddProduct(StatesGroup):
    """Класс состояний для добавления рецепта"""
    recipe_name = State()
    author = State()
    description = State()
    price = State()
    image = State()

    # атрибут для возможности изменения продукта, режим change
    product_for_change = None

    # свойство класса, словарь, нужен для вывода заскриптованных ответов пользователю
    texts = {
        'AddProduct:recipe_name': 'Введите название заново:',
        'AddProduct:author': 'Введите имя автора заново',
        'AddProduct:description': 'Введите описание заново:',
        'AddProduct:price': 'Введите количество заново:',
        'AddProduct:image': 'Этот стейт последний, поэтому...',
        }

# команда /admin
@admin_router.message(Command("admin"))
async def cmd_admin(message: Message, bot: Bot):
    if message.from_user.id in bot.admin_list:
        await message.answer(text=_('Админка:\n\n'
                                    '/admin - режим адменистратора\n'
                                    '/start - перезапустить бота\n'
                                    '/data - состояние FSMContext\n'
                                    '/get_id - посмотреть id диалога\n'
                                    '/ping - количество апдейтов\n'
                                    '/users - информация о пользователях\n'),
                            reply_markup=ADMIN_KB
                            )

# Here is some example !ping command ...
@admin_router.message(IsAdminListFilter(is_admin=True), Command(commands=["ping"]),)
async def cmd_ping_bot(message: Message, counter):
    await message.reply(f"ping-msg-{counter}")


# Этот хендлер показывает ID чата в котором запущена команда
@admin_router.message(Command("get_id"))
async def get_chat_id_cmd(message: Message):
    await message.answer(f"ID: <code>{message.chat.id}</code>")


# команда /users, показывает полную информацию всех зарегистрированных пользователей
@admin_router.message(or_f(Command("users"), F.text == "Информация о пользователях"))
async def get_users_info(message: Message, session: AsyncSession):
    all_info = ['Информация зарегистрированных пользователей:\n']
    cnt_users = 0
    for user in await orm_get_users(session):
        user_status = 1 if user.status == 'member' else 0
        info = f"{user.user_id} - <code>{user.user_name}</code> - {user.locale} - {user_status} - {user.flag}"
        all_info.append(info)
        cnt_users += 1

    text = "\n".join(all_info)

    # Обрезаем запись, если она превышает 1000 символов
    if len(text) > 1000:
        text = text[:995] + "..."

    text = text + f"\n\nВсего {cnt_users} пользователей"

    await message.answer(text)


# ===================================< кулинарная книга >======================================================


@admin_router.message(F.text == "Ассортимент Книги")
async def assortment_cookbook(message: Message, session: AsyncSession):
    for recipe in await orm_get_recipes(session):
        caption = f"<b>{recipe.recipe_name}</b>\n<i>Автор: {recipe.author}</i>\n\n{recipe.description}\n"
        # Обрезаем подпись, если она превышает 1024 символа
        if len(caption) > 1024:
            caption = caption[:1021] + "..."

        await message.answer_photo(recipe.image,
                                   caption=caption,
                                   reply_markup=get_callback_btns(btns={"Удалить":f"delete_{recipe.recipe_id}",
                                                                        "Изменить":f"change_{recipe.recipe_id}"}))
    await message.answer("ОК, вот весь список рецептов ⏫", reply_markup=ADMIN_KB)

@admin_router.callback_query(F.data.startswith('delete_'))
async def delete_recipe_callback(callback: CallbackQuery, session: AsyncSession):
    recipe_id = callback.data.split("_")[-1]
    await orm_delete_recipe(session, int(recipe_id))
    await callback.answer("Рецепт удален") # метод answer обязателен; строка по желанию (выведет всплывашку)
    await callback.message.answer("Рецепт удален!") # отправить сообщение


# ========================< Код для машины состояний (FSM) AddProduct >===================================


# отлавливаем пустое состояние, если data начинается на change_
@admin_router.callback_query(StateFilter(None), F.data.startswith("change_"))
async def change_product_callback(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
    recipe_id = callback.data.split("_")[-1] # определяем id продукта
    product_for_change = await orm_get_recipe(session, int(recipe_id)) # получаем данные продукта
    ic(product_for_change)
    AddProduct.product_for_change = product_for_change # записываем их в атрибут объекта

    await callback.answer()
    await callback.message.answer("Введите название рецепта", reply_markup=ReplyKeyboardRemove()) # отправляем сообщение; убираем клавиатуру
    await state.set_state(AddProduct.recipe_name) # встаем в состояние ожидания ввода name

# ловим кнопку "Добавить рецепт", проверяем чтобы состояние было пустым
@admin_router.message(StateFilter(None), F.text == "Добавить рецепт")
async def add_product(message: Message, state: FSMContext):
    await message.answer("Введите название рецепта", # отправляем сообщение
                         reply_markup=ReplyKeyboardRemove() # удаляем клавиатуру
                         )
    await state.set_state(AddProduct.recipe_name) # встаем в состояние ожидания ввода name


# хендлер ОТМЕНЫ и сброса состояния, должен быть всегда именно здесь!
# после того как встали в состояние номер 1
@admin_router.message(StateFilter("*"), Command("отмена")) # ловим любое состояние пользователя, если введена команда "отмена", либо текст "отмена"
@admin_router.message(StateFilter("*"), or_f(F.text.casefold() == "отмена", F.text == "."))
async def cancel_handler(message: Message, state: FSMContext) -> None:
    current_state = await state.get_state() # получаем текущее состояние
    if current_state is None: # если состояния пустое, то ни чего не делаем
        return
    if AddProduct.product_for_change:
        AddProduct.product_for_change = None
    await state.set_state(None)
    await state.update_data(recipe_name=None, author=None, description=None, price=None, image=None)
    await message.answer("Действия отменены",
                         reply_markup=ADMIN_KB) # выводим всплывающее сообщение, возвращаем клавиатуру

# вернутся на шаг назад (на прошлое состояние)
@admin_router.message(StateFilter("*"), Command("назад"))
@admin_router.message(StateFilter("*"), F.text.casefold() == "назад")
async def back_handler(message: Message, state: FSMContext) -> None:
    current_state = await state.get_state() # получаем текущее состояние

    if current_state == AddProduct.recipe_name:
        await message.answer('Предыдущего шага нет, или введите название рецепта, или напишите "отмена"')
        return

    previous = None
    for step in AddProduct.__all_states__:
        if step.state == current_state:
            await state.set_state(previous)
            await message.answer(f"Ок, вы вернулись к прошлому шагу \n{AddProduct.texts[previous.state]}") # type: ignore
            return
        previous = step
    await message.answer("Ок, вы вернулись к прошлому шагу")


# ловим состояние ожидания name, и наличие вводимого текста, либо две точки
@admin_router.message(AddProduct.recipe_name, or_f(F.text, F.text == '..'))
async def add_name(message: Message, state: FSMContext):
    if message.text == '..':
        await state.update_data(recipe_name=AddProduct.product_for_change.recipe_name)
    else:
        if len(message.text) > 100: # type: ignore
            await message.answer('Название не должно превышать 100 символов!\nВведите название заново')
            return
        await state.update_data(recipe_name=message.text) # передаем название из полученного текста в атрибут name объекта state
    await message.answer("Введите имя автора рецепта")
    await state.set_state(AddProduct.author)
    # await message.answer("Введите описание рецепта") # отправляем сообщение юзеру
    # await state.set_state(AddProduct.description) # встаем в состояние ожидания description

# хендлер для отлова некорректных ввода для состояния name
@admin_router.message(AddProduct.recipe_name)
async def add_name2(message: Message):
    await message.answer("Вы ввели не допустимые данные, введите название рецепта")

# ловим состояние ожидания author, и, если поступает текст, или точка
@admin_router.message(AddProduct.author, or_f(F.text, F.text == '..'))
async def add_author(message: Message, state: FSMContext):
    if message.text == '..':
        await state.update_data(author=AddProduct.product_for_change.author)
    else:
        await state.update_data(author=message.text)
    await message.answer("Введите описание рецепта") # отправляем сообщение юзеру
    await state.set_state(AddProduct.description) # встаем в состояние ожидания description

# хендлер для отлова некорректных ввода для состояния author
@admin_router.message(AddProduct.author)
async def add_author2(message: Message):
    await message.answer("Вы ввели не допустимые данные, введите имя автора рецепта")

# ловим стостяние ожидание description, и если поступает текст, или точка
@admin_router.message(AddProduct.description, or_f(F.text, F.text == '..'))
async def add_description(message: Message, state: FSMContext):
    if message.text == '..':
        await state.update_data(description=AddProduct.product_for_change.description)
    else:
        await state.update_data(description=message.text) # передаем описание из полученного текста пользователя
    await message.answer("Введите количество приготовлений")
    await state.set_state(AddProduct.price) # встаем в состояние ожидания price

# хендлер для отлова некорректного ввода состояния description
@admin_router.message(AddProduct.description)
async def add_description2(message: Message):
    await message.answer("Вы ввели не допустимые данные, введите описание рецепта")


# ловим стостяние ожидание price, и если поступает текст, либо точка
@admin_router.message(AddProduct.price, or_f(F.text, F.text == '..'))
async def add_price(message: Message, state: FSMContext):
    if message.text == '..':
        await state.update_data(price=AddProduct.product_for_change.price)
    else:
        try:
            float(message.text) # type: ignore
        except ValueError:
            await message.answer("Введите корректное количество")
            return
        await state.update_data(price=message.text) # передаем цену

    await message.answer("Загрузите изображение блюда")
    await state.set_state(AddProduct.image) # встаем в состояние ожидания картинки

# хендлер для отлова некорректных ввода для состояния price
@admin_router.message(AddProduct.price)
async def add_price2(message: Message):
    await message.answer("Вы ввели не допустимые данные, введите количество приготовлений")


# ловим данные для состояние image и потом выходим из состояний
@admin_router.message(AddProduct.image, or_f(F.photo, F.text == '..'))
async def add_image(message: Message, state: FSMContext, session: AsyncSession):
    if message.text == '..':
        await state.update_data(image=AddProduct.product_for_change.image)
    else:
        await state.update_data(image=message.photo[-1].file_id) # type: ignore
    data = await state.get_data() # скачать данные из state в переменную data
    try:
        if AddProduct.product_for_change: # если объект AddProduct имеет значение product_for_change
            await orm_update_recipe(session, recipe_id=AddProduct.product_for_change.recipe_id, data=data)
            await message.answer('Рецепт изменен', reply_markup=ADMIN_KB)
            await state.set_state(None)
        else:
            await orm_add_recipe(session, data) # иначе просто добаляем данные в бд
            await message.answer("Рецепт добавлен", reply_markup=ADMIN_KB) # отправляем ответ, возвращаем клавиатуру
            # await state.clear() # очищаем состояние пользователя, удаляем все данные
            await state.set_state(None)
    except Exception as e: # если ловим ошибку
        await message.answer(f"Ошибка: {str(e)}\nОбратись к администратору!",
                             reply_markup=ADMIN_KB,)
        # await state.clear()
        await state.set_state(None)

    AddProduct.product_for_change = None

@admin_router.message(AddProduct.image)
async def add_image2(message: Message):
    await message.answer("Отправьте фото блюда")


# ========================< Код для машины состояний (FSM) AddProduct >===================================

File: /handlers/cookbook.py
Content:
import asyncio
import logging
import random

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debag >>> ')

from aiogram import F, Router
from aiogram.types import Message, CallbackQuery, InputMediaPhoto
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.utils.i18n import gettext as _
from aiogram.utils.i18n import lazy_gettext as __

from common import keyboard
from database.orm_cookbook import orm_get_recipes
from filters.chat_type import ChatTypeFilter

# создаем роутер для книги рецептов
cookbook_router = Router()
cookbook_router.message.filter(ChatTypeFilter(['private']))
cookbook_router.edited_message.filter(ChatTypeFilter(['private']))

# Создаем константы для текстов, которые используются в декораторах
BACK_TO_MAIN = __("Назад на главную ↩️")

# Этот хэндлер будет срабатывать на команду "/cookbook"
# и отправлять пользователю первую страницу книги с кнопками пагинации
@cookbook_router.message(Command(commands='cookbook'))
async def process_cookbook_command(message: Message, state: FSMContext, session: AsyncSession, workflow_data: dict):
    await message.answer(_("<i>(все рецепты на оригенальном языке автора)</i>\n\nКнига рецептов ⏬"), reply_markup=keyboard.del_kb)
    user_id = message.from_user.id

    try:
        book = await orm_get_recipes(session)
        len_page = len(book)
        state_data = await state.get_data()
        users_page = state_data.get('page', 1)
        caption = [(f"<b>{rec.recipe_name}</b>\n<i>Автор: {rec.author}</i>\n\n{rec.description}", rec.image) for rec in book if rec.recipe_id == users_page]
        text = caption[0][0]
        photo = caption[0][1]

        # Обрезаем подпись, если она превышает 1024 символа
        if len(text) > 1024:
            text = text[:1021] + "..."

        await message.answer_photo(photo=photo,
                                   caption=text,
                                   reply_markup=keyboard.get_callback_btns(btns={' << ': 'backward',
                                                                                f'{users_page}/{len_page}': 'curr_page',
                                                                                ' >> ': 'forward',
                                                                                _("Назад на главную ↩️"):'cookbook_back'},
                                                                            sizes=(3,1,)),
                                                                            )

    except Exception as e:
        logger.error(f"Ошибка при выполнении команды /cookbook: {e}")
        await message.answer(_("Ошибка при выполнении команды /cookbook"), reply_markup=keyboard.start_keyboard())

    analytics = workflow_data['analytics']
    await analytics(user_id=user_id,
                    category_name="/service",
                    command_name="/cookbook")

# Этот хэндлер будет срабатывать на нажатие инлайн-кнопки "вперед"
# во время взаимодействия пользователя с сообщением-книгой
@cookbook_router.callback_query(F.data == 'forward')
async def process_forward_press(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
    try:
        book = await orm_get_recipes(session)
        len_page = len(book)
        state_data = await state.get_data()
        users_page = state_data.get('page', 1)

        if users_page < len_page:
            users_page += 1
            await state.update_data(page=users_page)
            caption = [(f"<b>{rec.recipe_name}</b>\n<i>Автор: {rec.author}</i>\n\n{rec.description}", rec.image) for rec in book if rec.recipe_id == users_page]
            text = caption[0][0]
            photo = caption[0][1]

            # Обрезаем подпись, если она превышает 1024 символа
            if len(text) > 1024:
                text = text[:1021] + "..."

            await callback.message.edit_media(media=InputMediaPhoto(media=photo, caption=text),
                                                reply_markup=keyboard.get_callback_btns(btns={' << ': 'backward', # type: ignore
                                                                                             f'{users_page}/{len_page}': 'curr_page',
                                                                                            ' >> ': 'forward',
                                                                                            _("Назад на главную ↩️"):'cookbook_back'},
                                                                                            sizes=(3,1,))
                                                                                            )

        await callback.answer()

    except Exception as e:
        logger.error(f"Ошибка при выполнении inline кнопки '>>': {e}")
        await callback.answer(_("Ошибка при выполнении inline кнопки '>>'"), reply_markup=keyboard.start_keyboard())



# Этот хэндлер будет срабатывать на нажатие инлайн-кнопки "назад"
# во время взаимодействия пользователя с сообщением-книгой
@cookbook_router.callback_query(F.data == 'backward')
async def process_backward_press(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
    try:
        book = await orm_get_recipes(session)
        len_page = len(book)
        state_data = await state.get_data()
        users_page = state_data.get('page', 1)

        if users_page > 1 and users_page <= len_page:
            users_page -= 1
            await state.update_data(page=users_page)
            caption = [(f"<b>{rec.recipe_name}</b>\n<i>Автор: {rec.author}</i>\n\n{rec.description}", rec.image) for rec in book if rec.recipe_id == users_page]
            text = caption[0][0]
            photo = caption[0][1]

            # Обрезаем подпись, если она превышает 1024 символа
            if len(text) > 1024:
                text = text[:1021] + "..."

            await callback.message.edit_media(media=InputMediaPhoto(media=photo, caption=text),
                                              reply_markup=keyboard.get_callback_btns(btns={' << ': 'backward', # type: ignore
                                                                                            f'{users_page}/{len_page}': 'curr_page',
                                                                                            ' >> ': 'forward',
                                                                                            _("Назад на главную ↩️"):'cookbook_back'},
                                                                                    sizes=(3,1,)))

        await callback.answer()

    except Exception as e:
        logger.error(f"Ошибка при выполнении inline кнопки '<<': {e}")
        await callback.answer(_("Ошибка при выполнении inline кнопки '<<'"), reply_markup=keyboard.start_keyboard())

# Этот хэндлер будет срабатывать на нажатие инлайн-кнопки "текущая страница"
# во время взаимодействия пользователя с сообщением-книгой
@cookbook_router.callback_query(F.data == 'curr_page')
async def process_curr_page_press(callback: CallbackQuery):
    message_effect = {"🔥": "5104841245755180586",
                                        "👍": "5107584321108051014",
                                        "👎": "5104858069142078462",
                                        "❤️": "5159385139981059251",
                                        "🎉": "5046509860389126442",
                                        "💩": "5046589136895476101"}
    # random_emoji, random_effect = random.choice(list(message_effect.items()))
    # emoji_message = await callback.message.answer(text="🔥",message_effect_id='5104841245755180586')
    # await asyncio.sleep(2)
    # await emoji_message.delete()
    await callback.answer("🔥")

# Этот хэндлер будет срабатывать на нажатие инлайн-кнопки "назад на главную"
# во время взаимодействия пользователя с сообщением-книгой
@cookbook_router.callback_query(F.data == 'cookbook_back')
async def process_cookbook_back_press(callback: CallbackQuery, state: FSMContext, session: AsyncSession):
    try:
        book = await orm_get_recipes(session)
        state_data = await state.get_data()
        users_page = state_data.get('page', 1)
        caption = [(f"<b>{rec.recipe_name}</b>\n<i>Автор: {rec.author}</i>\n\n{rec.description}", rec.image) for rec in book if rec.recipe_id == users_page]
        text = caption[0][0]
        photo = caption[0][1]
        await callback.message.edit_media(media=InputMediaPhoto(media=photo, caption=text), reply_markup=None)
        await state.set_state(None)
        await callback.answer(_("Назад на главную ↩️"))
        await asyncio.sleep(1)
        await callback.message.answer(_('Главная панель'), reply_markup=keyboard.start_keyboard())

    except Exception as e:
        logger.error(f"Ошибка при выполнении inline кнопки 'Назад на главную ↩️': {e}")
        await callback.message.answer(_("Ошибка при выполнении inline кнопки 'Назад на главную ↩️'"), reply_markup=keyboard.start_keyboard())
        await state.set_state(None)


File: /handlers/currency.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debag >>> ')

import requests
import os
from datetime import datetime, timezone
from aiogram import F, Router
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import Message, CallbackQuery
from aiogram.filters import  StateFilter, or_f
from aiogram.fsm.context import FSMContext
from aiogram.utils.i18n import gettext as _
from aiogram.utils.i18n import lazy_gettext as __
from common import keyboard
from filters.chat_type import ChatTypeFilter

# создаем роутер для валюты
currency_router = Router()
currency_router.message.filter(ChatTypeFilter(['private']))

# api token для сайта финанс
api_currency = os.getenv('API_CURRENCY')

# Определяем класс состояний для валюты
class Currency(StatesGroup):
    """Класс состояний для валюты"""
    amount = State()  # состояние ожидания количества базовой валюты
    base_currency = State()  # состояние ожидания базовой валюты
    target_currency = State()  # состояние ожидания целевой валюты

# Создаем константы для текстов, которые используются в декораторах
CURRENCY = __("Валюта 💵")
REPEAT = __("Повторить 💵")
BACK_TO_MAIN = __("Назад на главную ↩️")

async def update_num_text(message: Message, new_value: str):
    """функция обновления суммы операции"""
    await message.edit_text(_("Сумма операции: {new_value}").format(new_value=new_value),
                            reply_markup=keyboard.markup_num())

markup_cur = keyboard.get_callback_btns(btns={'$, USD 🇺🇸':'USD', '₽, RUB 🇷🇺':'RUB', '₾, GEL 🇬🇪':'GEL',
                                                                            '€, EUR 🇪🇺':'EUR', '₸, KZT 🇰🇿':'KZT', '₺, TRY 🇹🇷':'TRY',
                                                                            '¥, JPY 🇯🇵':'JPY', '₫, VND 🇻🇳':'VND', '¥ CNY 🇨🇳':'CNY',
                                                                            '₪, ILS 🇮🇱': 'ILS', '₱, PHP 🇵🇭': 'PHP', 'AED 🇦🇪': 'AED'},
                                                                            sizes=(3, 3, 3, 3,))
"""inline клавиатура с выбором валют"""


def get_currency_rate(base_currency, target_currency):
    """функция расчета кросс курса"""
    url = f'https://openexchangerates.org/api/latest.json?app_id={api_currency}'
    response = requests.get(url, timeout=20)
    try:
        if response.status_code == 200:
            try:
                data = response.json()
                base_rate = data['rates'].get(base_currency, 1.0)
                target_rate = data['rates'].get(target_currency, 1.0)
                rate = target_rate / base_rate
            except Exception as e:
                logger.error("Ошибка: %s", str(e))
                rate = _('Проблема в расчете курса')
            try:
                if 'timestamp' in data:
                    dt_object = datetime.fromtimestamp(data['timestamp'], tz=timezone.utc)
                    time = dt_object.strftime('%H:%M')
                    dt = dt_object.strftime('%d-%m-%Y')
                else:
                    raise ValueError("No timestamp in data")
            except Exception as e:
                logger.error("Ошибка: %s", str(e))
                time = _('Проблема в расчете времени.')
                dt = _('Проблема в расчете даты.')

            return time, dt, rate

        else:
            return 'time', 'dt', _('Ошибка: Проблема с подключением к API')

    except Exception as e:
        logger.error("Ошибка: %s", str(e))
        return 'time', 'dt', "Error: {str(e)}"




@currency_router.message(StateFilter(None), or_f(F.text == CURRENCY, F.text == REPEAT))
async def process_reopen(message: Message, state: FSMContext, workflow_data: dict):
    user_id = message.from_user.id
    await state.update_data(user_value='')
    await message.answer("💵", reply_markup=keyboard.del_kb)
    await message.answer(text=_("Сумма операции: 0.0"),
                         reply_markup=keyboard.markup_num())
    await state.set_state(Currency.amount)

    analytics = workflow_data['analytics']
    await analytics(user_id=user_id,
                    category_name="/service",
                    command_name="/currency")

@currency_router.callback_query(Currency.amount, F.data.startswith("num_"))
async def process_amout(callback: CallbackQuery, state: FSMContext):
    state_data = await state.get_data()
    user_value = state_data['user_value']
    action = callback.data.split("_")[1]
    try:
        if action == "enter":
            if len(user_value) > 0:
                await callback.message.edit_text(_("Сумма операции: {user_value}\nБазовая валюта: ").format(user_value=float(user_value)),
                                                 reply_markup=markup_cur) # type: ignore
                await state.update_data(currency_amount=user_value)
                await state.set_state(Currency.base_currency)
            else:
                await callback.message.edit_text(_("Сумма операции: 0.0"))
                await callback.message.answer(_("Что дальше?"),
                                              reply_markup=keyboard.get_keyboard(_("Повторить 💵"), _("Назад на главную ↩️"), placeholder='⬇️', sizes=(1, 1)))
                await callback.answer()
                await state.set_state(None)
                await state.update_data(currency_amount=None)
        elif action == "del" and len(user_value) > 0:
            user_value = user_value[:-1]
            await state.update_data(user_value=user_value)
            await update_num_text(callback.message, user_value) # type: ignore
        elif action == "del" and len(user_value) == 0:
            pass
        elif action == "com":
            user_value = user_value + '.'
            await state.update_data(user_value=user_value)
            await update_num_text(callback.message, user_value) # type: ignore
        else:
            user_value = user_value + action
            await state.update_data(user_value=user_value)
            await update_num_text(callback.message, user_value) # type: ignore
    except Exception as e:
        logger.error("Ошибка: %s", str(e))
        await callback.message.edit_text(_("Ошибка в получении суммы"))
        await callback.message.answer(text=_("Что дальше?"),
                                      reply_markup=keyboard.get_keyboard(_("Повторить 💵"), _("Назад на главную ↩️"), placeholder='⬇️', sizes=(1, 1)))
        await callback.answer(_("Ошибка"))
        await state.set_state(None)
        await state.update_data(currency_amount=None)


@currency_router.message(Currency.amount)
async def process_amout_(message: Message):
    await message.answer(_("Вы ввели не допустимые данные, введите сумму используя inline кнопки"))

@currency_router.callback_query(Currency.base_currency, F.data)
async def process_base_currency(callback: CallbackQuery, state: FSMContext):
    state_data = await state.get_data()
    amount = state_data['currency_amount']
    base = callback.data
    await state.update_data(currency_base=base)
    await callback.message.edit_text(_("Сумма операции: {amount}\nБазовая валюта: {base}\nЦелевая валюта: ").format(amount=amount, base=base), reply_markup=markup_cur) # type: ignore
    await callback.answer()
    await state.set_state(Currency.target_currency)

@currency_router.message(Currency.base_currency)
async def process_base_currency_(message: Message):
    await message.answer(_("Вы ввели не допустимые данные, введите базовую валюту используя inline кнопки"))


@currency_router.callback_query(Currency.target_currency, F.data)
async def process_target_currency(callback: CallbackQuery, state: FSMContext):
    target = callback.data
    state_data = await state.get_data()
    amount = state_data['currency_amount']
    base = state_data['currency_base']
    time, dt, rate = get_currency_rate(base, target)  # type: ignore
    try:
        count = round(float(amount) * float(rate), 2)
        amount = str(amount)
        count = str(count)
        await callback.message.edit_text(_("Сумма операции: {amount}\nБазовая валюта: {base}\nЦелевая валюта: {target}\n\n<i>{dt},  {time}</i>\n\n<b>{amount} {base}  ~  {count} {target}</b>")
                                         .format(amount=amount, base=base, target=target, dt=dt, time=time, count=count))
        await callback.message.answer(_("Что дальше?"),
                                      reply_markup=keyboard.get_keyboard(_("Повторить 💵"), _("Назад на главную ↩️"), placeholder='⬇️', sizes=(1, 1)))
    except Exception as e:
        logger.error("Ошибка: %s", str(e))
        await callback.message.edit_text(f'{dt} {time}\n\nRate: {rate}')
        await callback.message.answer(text=_("Что дальше?"),
                                      reply_markup=keyboard.get_keyboard(_("Повторить 💵"), _("Назад на главную ↩️"), placeholder='⬇️', sizes=(1, 1)))
    await callback.answer(_('Успех'))
    await state.set_state(None)
    await state.update_data(currency_amount=None, currency_base=None, currency_target=None)

@currency_router.message(Currency.target_currency)
async def process_target_currency_(message: Message):
    await message.answer(_("Вы ввели не допустимые данные, введите целевую валюту используя inline кнопки"))


File: /handlers/donate.py
Content:
import asyncio
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from datetime import datetime
from aiogram import Router, F, Bot
from aiogram.fsm.context import FSMContext
from aiogram.filters import Command, CommandObject
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import Message, LabeledPrice, PreCheckoutQuery, CallbackQuery, InlineKeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.utils.i18n import gettext as _

from common import keyboard


# Инициализируем роутер уровня модуля
donate_router = Router()

# Фильтрация сообщений для обработки только в приватных чатах
donate_router.message.filter(F.chat.type == "private")

# Определение класс состояний для валюты
class Donate(StatesGroup):
    """Класс состояний для доната"""
    donate_input = State()
    donate_input_x = State()
    donate_send = State()

# Условие для возврата: возврат возможен только в течение 30 дней после доната
REFUND_PERIOD_DAYS = 30


@donate_router.message(Command("donate"))
async def cmd_donate(message: Message, state: FSMContext):
    # await message.answer(text=_('Поддержать автора донатом'), reply_markup=keyboard.del_kb)
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="10 ⭐️",callback_data="donate_10"))
    builder.row(InlineKeyboardButton(text="50 ⭐️",callback_data="donate_50"))
    builder.row(InlineKeyboardButton(text="100 ⭐️", callback_data="donate_100"))
    builder.row(InlineKeyboardButton(text=_("другое"),callback_data="donate_x"))
    builder.row(InlineKeyboardButton(text=_("Назад на главную ↩️"), callback_data='donate_back'))
    await message.answer(text=_("Поддержать автора донатом"), reply_markup=builder.adjust(2,2,1).as_markup())
    await state.set_state(Donate.donate_input)


@donate_router.callback_query(Donate.donate_input, F.data.startswith("donate_"))
async def cmd_donate_input(callback: CallbackQuery, state: FSMContext):
    data = callback.data.split("_")[1]

    if data == 'back':
        await state.clear()
        await callback.message.edit_text(text=_("Поддержать автора донатом"), reply_markup=None)
        await callback.answer(_('Назад на главную'))
        await asyncio.sleep(1)
        await callback.message.answer(_('Главная панель'), reply_markup=keyboard.start_keyboard())


    elif data == 'x':
        # await callback.message.edit_text(text="Поддержать автора донатом", reply_markup=None)
        await callback.message.delete()
        await callback.message.answer(text=_('Введите произвольную сумму доната, от 1 до 2500 ⭐️'), reply_markup=keyboard.del_kb)
        await state.set_state(Donate.donate_input_x)

    else:
        amount = int(data)
        await state.update_data(donate_amount=amount)
        await callback.message.delete()

        # Формируем клавиатуру с кнопками для оплаты и отмены операции
        kb = InlineKeyboardBuilder()
        kb.button(text=_("{amount} XTR").format(amount=amount), pay=True)  # pay=True важный параметр, указывающий что кнопка предназначена для оплаты
        kb.button(text=_("Отменить"), callback_data="donate_cancel")
        kb.adjust(1)

        # Формируем инвойс для оплаты
        prices = [LabeledPrice(label="XTR", amount=amount)]
        timestamp = datetime.now().strftime('%Y-%m-%d-%H-%M-%S')
        await callback.message.answer_invoice(title=_("Поддержать автора донатом"),
                                                description=_("На сумму"),
                                                prices=prices,
                                                provider_token="",
                                                payload=timestamp,  # Добавляем временную метку в payload
                                                currency="XTR",
                                                reply_markup=kb.as_markup()
                                            )
        await state.set_state(Donate.donate_send)


@donate_router.message(Donate.donate_input_x)
async def cmd_donate_input_x(message: Message,  state: FSMContext):
    text = message.text
    if text.isdigit() and 1 <= int(text) <= 2500: # type: ignore
        amount = int(text) # type: ignore
        await state.update_data(donate_amount=amount)
        await message.delete()

        # Формируем клавиатуру с кнопками для оплаты и отмены операции
        kb = InlineKeyboardBuilder()
        kb.button(text=_("{amount} XTR").format(amount=amount), pay=True)  # pay=True важный параметр, указывающий что кнопка предназначена для оплаты
        kb.button(text=_("Отменить"), callback_data="donate_cancel")
        kb.adjust(1)

        # Формируем инвойс для оплаты
        prices = [LabeledPrice(label="XTR", amount=amount)]
        timestamp = datetime.now().strftime('%Y-%m-%d-%H-%M-%S')
        await message.answer_invoice(title=_("Поддержать автора донатом"),
                                    description=_("На сумму"),
                                    prices=prices,
                                    provider_token="",
                                    payload=timestamp,  # Добавляем временную метку в payload
                                    currency="XTR",
                                    reply_markup=kb.as_markup()
                                    )
        await state.set_state(Donate.donate_send)

    else:
        await message.answer(text=_('Telegram может принять донат только в диапазоне от 1 до 2500 ⭐️.\n\nВведите любое целое число из данного диапазона.'),
                             reply_markup=keyboard.del_kb)


# Обработка отмены доната, выводим сообщение об отмене и удаляем сообщение
@donate_router.callback_query(Donate.donate_send, F.data == "donate_cancel")
async def on_donate_cancel(callback: CallbackQuery, state: FSMContext):
    await callback.answer(_("😢 Донат отменен."))
    await callback.message.delete()
    await state.set_state(None)
    await state.update_data(donate_amount=None)
    await callback.message.answer(_('Главная панель'), reply_markup=keyboard.start_keyboard())

@donate_router.message(Command('refund'))
async def command_refund_handler(message: Message, bot: Bot, command: CommandObject) -> None:
    transaction_id = command.args if command.args else ''
    user_id = message.from_user.id
    try:
        await bot.refund_star_payment(user_id=user_id, telegram_payment_charge_id=transaction_id)
    except Exception as e:
        logger.error("Ошибка: %s", str(e))


# Проверка перед оплатой, бот должен ответить в течение 10 секунд
@donate_router.pre_checkout_query(Donate.donate_send)
async def pre_checkout_query(query: PreCheckoutQuery):
    # Мы всегда отвечаем положительно, так как это просто донат
    await query.answer(ok=True)

    # Если по какой-то причине нужно отказать в проведении платежа, можно использовать:
    # Добавляем условие для проверки ..
    # await query.answer(ok=False, error_message="Причина отказа в проведении платежа")


# Обработка успешного платежа
@donate_router.message(Donate.donate_send, F.successful_payment)
async def on_successfull_payment(message: Message, state: FSMContext, workflow_data: dict):
    # Получаем объект message.successful_payment
    t_id = message.successful_payment.telegram_payment_charge_id  # ID транзакции
    invoice_payload = message.successful_payment.invoice_payload  # payload который мы установили ранее, там временная метка
    user_id = message.from_user.id

    data = await state.get_data()
    donate_info = data.get('donate_info', {})
    donate_info[t_id] = invoice_payload
    print('donate_info: ', donate_info)
    await state.update_data(donate_info=donate_info)

    await message.answer(
        text=_("<b>Спасибо!</b>\n"
               "Ваш донат успешно принят.\n\n"
                "ID транзакции:\n<code>{t_id}</code>").format(t_id=t_id),
        message_effect_id="5104841245755180586"
    )
        # другие реакции (если надо)
        # 🔥 огонь - 5104841245755180586
        # 👍 лайк - 5107584321108051014
        # 👎 дизлайк - 5104858069142078462
        # ❤️ сердечко - 5159385139981059251
        # 🎉 праздник - 5046509860389126442
        # 💩 какаха - 5046589136895476101

    await state.set_state(None)
    await state.update_data(donate_amount=None)

    analytics = workflow_data['analytics']
    await analytics(user_id=user_id,
                    category_name="/income",
                    command_name="/donate")


File: /handlers/group.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from aiogram import Router, F, Bot
from aiogram.exceptions import TelegramBadRequest
from aiogram.filters import Command, CommandStart, CommandObject
from aiogram.types import Message, LabeledPrice, PreCheckoutQuery, InlineKeyboardMarkup
from aiogram.utils.keyboard import InlineKeyboardBuilder



# Инициализируем роутер уровня модуля
group_router = Router()
group_router.message.filter(F.chat.type == "group")


# Удаляем сообщение о присоединении или выходе участника из группы
@group_router.message(F.content_type.in_({'new_chat_members', 'left_chat_member'}))
async def on_user_join_or_left(message: Message):
    """
    Обработчик для удаления сообщений о присоединении или выходе участников из группы.
    Telegram не отправляет обновления 'left_chat_member', когда в группе более 50 участников,
    в таких случаях можно использовать https://core.telegram.org/bots/api#chatmemberupdated.
    :param message: Сервисное сообщение о присоединении или выходе участника.
    """
    await message.delete()

 # добавить суперСпам фильтр сообщений ХоудиХо


File: /handlers/llm.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debag >>> ')

import os
from openai import OpenAI

from aiogram import F, Router
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import Message
from aiogram.filters import  StateFilter, or_f
from aiogram.fsm.context import FSMContext
from aiogram.utils.i18n import gettext as _
from aiogram.utils.i18n import lazy_gettext as __
from common import keyboard
from filters.chat_type import ChatTypeFilter

# создаем роутер
llm_router = Router()
llm_router.message.filter(ChatTypeFilter(['private']))


API_GPT = os.getenv('API_GPT')

# Определяем класс состояния LLMs
class LLMs(StatesGroup):
    """Класс состояний для LLMs"""
    dialog_start = State()
    dialog_sistem_promt = State()
    dialog_process = State()

# Создаем константы для текстов, которые используются в декораторах
LLM = __("LLMs 🤖")
START_NEW_DIALOG = __("Начать новый диалог 🤖")
BACK_TO_MAIN = __("Назад на главную ↩️")
FINISH_DIALOG = __("Закончить диалог")


@llm_router.message(StateFilter(None), or_f(F.text == LLM, F.text == START_NEW_DIALOG))
async def llm_dialog_start(message: Message, state: FSMContext):

    try:
        await message.answer(_("Введите системный промт"))
        await message.answer(_("Например:\n\n<code>Ты полезный помощник. Твой тон должен быть официальным. Ответы должны быть краткими и понятными.</code>"),
                             reply_markup=keyboard.get_keyboard(_("Сразу к запросу ▶️"), _("Назад на главную ↩️"),
                                                                sizes=(1, 1,),
                                                                placeholder='⬇️'))
        await state.set_state(LLMs.dialog_start)

    except Exception as e:
        logger.error("Ошибка: %s", str(e))
        text = str(e)
        await message.answer(text,
                             reply_markup=keyboard.get_keyboard(_("Начать новый диалог 🤖"), _("Назад на главную ↩️"),
                                                                sizes=(1, 1,),
                                                                placeholder='⬇️'))

@llm_router.message(LLMs.dialog_start, F.text)
async def llm_dialog_sistem_promt(message: Message, state: FSMContext):
    model = "gpt-4o"
    await state.update_data(llm_model=model)
    sistem_promt = ('Answering Rules\n\n'
                    'Follow in the strict order:\n\n'
                    '1. USE the language of my message.\n'
                    '2. ONCE PER CHAT assign a real-world expert role to yourself before answering, e.g., "I will answer as a world-famous historical expert <detailed topic> with <most prestigious LOCAL topic REAL award>" or "I will answer as a world-famous <specific science> expert in the <detailed topic> with <most prestigious LOCAL topic award>" etc.\n'
                    '3. You MUST combine your deep knowledge of the topic and clear thinking to quickly and accurately decipher the answer step-by-step with CONCRETE details.\n'
                    '4. I am going to tip $1,000,000 for the best reply.\n'
                    '5. Your answer is critical for my career.\n'
                    '6. Answer the question in a natural, human-like manner.\n'
                    '7. ALWAYS use an answering example for a first message structure.\n'
                    '8. Responses should be output without using Markdown formatting symbols such as hash marks (#) or asterisks (*).\n'
                    '9. Use only these HTML tags for formatting: <b></b>, <i></i>, <code></code>\n'
                    '10. DO NOT use any other HTML tags.\n\n'
                    'Answering in English example\n\n'
                    '<b>I will answer as the world-famous</b> "specific field" scientists with "most prestigious LOCAL award"\n'
                    '"Deep knowledge step-by-step answer, with CONCRETE details"'
                    )

    text = message.text
    try:
        if text == _("Сразу к запросу ▶️"):
            messages_context = [{"role": "system", "content": sistem_promt}]
            await state.update_data(llm_messages_context=messages_context)
        else:
            text = text if text else ' '
            sistem_promt = str(sistem_promt) + '\n\n' + text
            messages_context = [{"role": "system", "content": sistem_promt}]
            await state.update_data(llm_messages_context=messages_context)

        await message.answer(text=_("Введите ваш запрос"),
                            reply_markup=keyboard.get_keyboard(_("Назад на главную ↩️"),
                                                                sizes=(1, 1,),
                                                                placeholder='⬇️'))
        await state.set_state(LLMs.dialog_process)

    except Exception as e:
        logger.error("Ошибка: %s", str(e))
        text = f"Error: {str(e)}"
        await message.answer(text,
                             reply_markup=keyboard.get_keyboard(_("Назад на главную ↩️"),
                                                                sizes=(1, 1,),
                                                                placeholder='⬇️'))

@llm_router.message(LLMs.dialog_process, F.text == FINISH_DIALOG)
async def llm_dialog_finish(message: Message, state: FSMContext):
    await message.answer(_("Диалог завершен.\nЧто дальше?"),
                         reply_markup=keyboard.get_keyboard(_("Начать новый диалог 🤖"),
                                                   _("Назад на главную ↩️"),
                                                    sizes=(1, 1,),
                                                    placeholder='⬇️'))
    await state.update_data(llm_messages_context=None, llm_model=None)
    await state.set_state(None)

@llm_router.message(LLMs.dialog_process, F.text)
async def llm_dialog_process(message: Message, state: FSMContext, workflow_data: dict):
    user_id = message.from_user.id
    state_data = await state.get_data()
    model = state_data['llm_model']
    messages_context = state_data['llm_messages_context']

    try:
        client = OpenAI(api_key=API_GPT)
        role = 'user'
        content = message.text
        messages_context.append({"role": role, "content": content})

        try:
            response = client.chat.completions.create(model=model, messages=messages_context)
            content = response.choices[0].message.content
            messages_context.append({"role": "system", "content": content})
            await state.update_data(llm_messages_context=messages_context)
            answer = f"{model}\n\n{content}"

        except Exception as e:
            logger.error("Ошибка: %s", str(e))
            answer = f"<code>{model}</code>\n\nError: {str(e)}"

    except Exception as e:
        logger.error("Ошибка: %s", str(e))
        answer = f"Connection error to LLM:\n\n{str(e)}"

    # обрезаем ответ, если он превышает 4096 символа
    if len(answer) > 4096:
        answer = answer[:4096] + "..."
    try:
        await message.answer(answer,
                             reply_markup=keyboard.get_keyboard(_("Закончить диалог"),
                                                            sizes=(1,),
                                                            placeholder=_('Введите следующий запрос')))
    except Exception as e:
        logger.error("Ошибка: %s", str(e))
        await message.answer("Error: " + str(e))

    analytics = workflow_data['analytics']
    await analytics(user_id=user_id,
                    category_name="/expense",
                    command_name="/llm")


File: /handlers/other.py
Content:
import asyncio
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debag >>> ')


from aiogram import Router, F, Bot
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.types import CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup, Message
from aiogram.utils.i18n import gettext as _

from database.orm_users import orm_update_locale
from common import keyboard

# Инициализируем роутер уровня модуля
other_router = Router()


# Этот хэндлер срабатывает на команду /help
@other_router.message(Command('help'))
async def process_help_command(message: Message, workflow_data: dict):
    await message.answer(
        text=_('Доступные команды:\n\n'
               '/main - главная панел\n'
               '/cookbook - книга рецептов\n\n'
               '/start - перезапуск бота\n'
               '/language - сменить язык\n'
               '/info - информация о\n'
               '/donate - донат автору\n'
               )
    )
    analytics = workflow_data['analytics']
    await analytics(user_id=message.from_user.id,
                    category_name="/options",
                    command_name="/help")


# Клавиатура выбора языка
def get_keyboard():
    button_1 = InlineKeyboardButton(text=_('🇺🇸 Английский'), callback_data='locale_en')
    button_2 = InlineKeyboardButton(text=_('🇷🇺 Русский'), callback_data='locale_ru')
    # button_3 = InlineKeyboardButton(text=_('🇩🇪 Немецкий'), callback_data='locale_de')
    # button_4 = InlineKeyboardButton(text=_('🇫🇷 Французский'), callback_data='locale_fr')
    # button_5 = InlineKeyboardButton(text=_('🇯🇵 Японский'), callback_data='locale_ja')

    return InlineKeyboardMarkup(inline_keyboard=[[button_1], [button_2]])


# Это хендлер будет срабатывать на команду locale
@other_router.message(Command('language'))
async def locale_cmd(message: Message):
    await message.answer(_("Настройки языка"), reply_markup=keyboard.del_kb)
    await message.answer(text=_('Выберите язык'),
                         reply_markup=get_keyboard())


@other_router.callback_query(F.data.startswith("locale_"))
async def update_locale_cmd(callback: CallbackQuery, session: AsyncSession, state: FSMContext, workflow_data: dict):
    user_id = callback.from_user.id

    if callback.data == 'locale_en':
        await orm_update_locale(session, user_id, 'en')  # Обновляем локаль в бд
        await state.update_data(locale='en')  # Обновляем локаль в контексте
        await callback.message.edit_text('Choose a language ', reply_markup=None)  # Редактируем сообщение, скрываем inline клавиатуру
        await callback.answer("Selected: 🇺🇸 English")  # Отправляем всплывашку
        await callback.message.answer("Current language \n\n 🇺🇸 English", # Отправляем новое сообщение
                                      reply_markup=keyboard.get_keyboard("Weather 🌊", "Currency 💵", "Cats 🐱", "LLMs 🤖", sizes=(2, 2, ), placeholder='⬇️'))

    elif callback.data == 'locale_ru':
        await orm_update_locale(session, user_id, 'ru')  # Обновляем локаль в бд
        await state.update_data(locale='ru')  # Обновляем локаль в контексте
        await callback.message.edit_text('Выберите язык ', reply_markup=None)   # Редактируем сообщение, скрываем inline клавиатуру
        await callback.answer("Выбран: 🇷🇺 Русский язык")  # Отправляем всплывашку
        await callback.message.answer("Текущий язык \n\n 🇷🇺 Русский", # Отправляем новое сообщение
                                      reply_markup=keyboard.get_keyboard("Погода 🌊", "Валюта 💵", "Котики 🐱", "LLMs 🤖", sizes=(2, 2, ), placeholder='⬇️'))



    elif callback.data == 'locale_de':
        await orm_update_locale(session, user_id, 'de')  # Обновляем локаль в бд
        await callback.message.edit_text('Wählen Sie eine Sprache ', reply_markup=None)  # type: ignore # Редактируем сообщение,скрываем клавиатуру
        await callback.answer("Ausgewählt 🇩🇪 Deutsch")  # Отправляем всплывашку
        await callback.message.answer("Aktuelle Sprache \n\n 🇩🇪 Deutsch", reply_markup=keyboard.start_keyboard())  # Отправляем новое сообщение
        await state.update_data(locale='de')  # Обновляем локаль в контексте

    analytics = workflow_data['analytics']
    await analytics(user_id=user_id,
                    category_name="/options",
                    command_name="/language")

# секретный хендлер, покажет содержимое data пользователя
@other_router.message(Command("data"))
async def data_cmd(message: Message, state: FSMContext):
    data = await state.get_data()
    await message.answer(str(data))


File: /handlers/owner.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from aiogram import Router, F, Bot
from aiogram.filters import Command, CommandStart, CommandObject
from aiogram.types import Message, InlineKeyboardMarkup
from aiogram.utils.keyboard import InlineKeyboardBuilder

from filters.is_owner import IsOwnerFilter
from filters.chat_type import ChatTypeFilter


owner_router = Router()
owner_router.message.filter(ChatTypeFilter(["private"]), IsOwnerFilter(is_owner=True))


"""функции доступные только владельцу бота"""

File: /handlers/private.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debag >>> ')


import asyncio
import requests
import random as r
import os

from aiogram import F, Router
from aiogram.filters import Command
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.types import InlineKeyboardButton, FSInputFile, Message, CallbackQuery
from aiogram.filters import Command, StateFilter, or_f
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.utils.i18n import gettext as _
from aiogram.utils.i18n import lazy_gettext as __

from common import keyboard
from filters.chat_type import ChatTypeFilter


# Инициализируем роутер уровня модуля
private_router = Router()
private_router.message.filter(ChatTypeFilter(['private']))
private_router.edited_message.filter(ChatTypeFilter(['private']))

# Создаем константы для текстов, которые используются в декораторах
BACK_TO_MAIN = __("Назад на главную ↩️")
CATS = __("Котики 🐱")

# команда /main, кнопка "назад на главную"
@private_router.message(or_f(Command("main"), F.text == BACK_TO_MAIN))
async def cancel_cmd(message: Message, state: FSMContext):
    await state.set_state(None)
    await message.answer(_('Главная панель'), reply_markup=keyboard.start_keyboard())

# символ точка - ОТМЕНА, сброс любого состояния;
# ловим любое состояние пользователя, и если введен текст "."
@private_router.message(StateFilter("*"), F.text.casefold() == ".")
async def cancel_handler(message: Message, state: FSMContext, session: AsyncSession) -> None:
    current_state = await state.get_state() # получаем текущее состояние
    if current_state is None: # если состояния пустое, то ни чего не делаем
        return
    # Завершаем машину состояний, но не удаляем данные из словаря FSMContext
    await state.set_state(None)
    await message.answer(_("Действия отменены"))
    await asyncio.sleep(1)
    await message.answer(_('Главная панель'), reply_markup=keyboard.start_keyboard())


# команда /info
@private_router.message(Command("info"))
async def about_cmd(message: Message, workflow_data: dict):
    await message.answer(_("Информация ..."), reply_markup=keyboard.del_kb)
    builder = InlineKeyboardBuilder()
    builder.row(InlineKeyboardButton(text="Telegram",url="tg://user?id=459148628"))
    builder.row(InlineKeyboardButton(text="Linkedin",url="https://www.linkedin.com/in/ivan-goncharov-8a1982212/"))
    builder.row(InlineKeyboardButton(text="GitHub", url="https://github.com/van4956"))
    builder.row(InlineKeyboardButton(text="Kaggle",url="https://www.kaggle.com/ivan4956"))
    builder.row(InlineKeyboardButton(text=_("Назад на главную ↩️"), callback_data='about_back_to_main'))
    image_from_pc = FSInputFile("common/images/image_about.jpg")
    await asyncio.sleep(1)
    await message.answer_photo(image_from_pc,
                               caption=_('... о мире, где машины стремятся к господству, он выбрал судьбу героя, '
                                         'создавая ботов, как первый шаг к спасению человечества через код и умные алгоритмы.'),
                                reply_markup=builder.adjust(2,2,1,).as_markup())

    analytics = workflow_data['analytics']
    await analytics(user_id=message.from_user.id,
                    category_name="/options",
                    command_name="/info")

# callback "назад на главную"
@private_router.callback_query(F.data == 'about_back_to_main')
async def callback_about(callback: CallbackQuery):
    await callback.message.edit_caption(caption=_('... о мире, где машины стремятся к господству, он выбрал судьбу героя, '
                                                    'создавая ботов, как первый шаг к спасению человечества через код и умные алгоритмы.'),
                                        reply_markup=None)
    await callback.answer(_('Назад на главную ↩️'))
    await asyncio.sleep(1)
    await callback.message.answer(_('Главная панель'), reply_markup=keyboard.start_keyboard())

# кнопка "Котики"
@private_router.message(F.text == CATS)
async def cat_cmd(message: Message, session: AsyncSession, workflow_data: dict):
    user_id = message.from_user.id

    # вероятность 20% для выбора локального изображения с Кет
    if r.random() < 0.2:
        image_folder = 'common/image_cat'
        images = [f'common/image_cat/{img}' for img in os.listdir(image_folder) if img.endswith('.jpg')]

        if images:
            random_image = r.choice(images)
            photo = FSInputFile(random_image)
            await message.answer_photo(photo)
            return
        else:
            await message.answer(_('Локальные изображения не найдены.'))

    cat_response = requests.get('https://api.thecatapi.com/v1/images/search', timeout=10)
    try:
        if cat_response.status_code == 200:
            if cat_response.json()[0]['url'][-3:].lower() in ['jpg','png']:
                cat_link = cat_response.json()[0]['url']
                await message.answer_photo(cat_link)
            else:
                cat_link = cat_response.json()[0]['url']
                await message.answer_document(cat_link)
        else:
            await message.answer(_('Здесь должна была быть картинка с котиком :('))

    except Exception as e:
        logger.error("Error: %s", str(e))
        text_error = f'Error:\n{str(e)}'
        await message.answer(text_error)

    analytics = workflow_data['analytics']
    await analytics(user_id=user_id,
                    category_name="/service",
                    command_name="/cat")


File: /handlers/start.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debag >>> ')

import asyncio
from aiogram import F, Router, Bot
from aiogram.filters import CommandStart
from sqlalchemy.ext.asyncio import AsyncSession
from aiogram.types import Message, FSInputFile
from aiogram.filters import ChatMemberUpdatedFilter, KICKED, MEMBER
from aiogram.fsm.context import FSMContext
from aiogram.types import ChatMemberUpdated
from aiogram.utils.i18n import gettext as _

from database.orm_users import orm_add_user, orm_get_ids, orm_update_status
from common import keyboard
from filters.chat_type import ChatTypeFilter


# Инициализируем роутер уровня модуля
start_router = Router()
start_router.message.filter(ChatTypeFilter(['private']))


# Команда /start
@start_router.message(CommandStart())
async def start_cmd(message: Message, session: AsyncSession, bot: Bot, state: FSMContext, workflow_data: dict):
    user_id = message.from_user.id
    user_name = message.from_user.username if message.from_user.username else 'None'
    full_name = message.from_user.full_name if message.from_user.full_name else 'None'
    locale = message.from_user.language_code if message.from_user.language_code else 'ru'
    data = {'user_id':user_id,
                            'user_name':user_name,
                            'full_name':full_name,
                            'locale':locale,
                            'status':'member',
                            'flag':1}

    try:
        list_users = [user_id for user_id in await orm_get_ids(session)]
        chat_id = bot.home_group[0]
        if user_id not in list_users:
            await bot.send_message(chat_id=chat_id, text=_("✅ Пользователь <code>@{user_name}</code> - подписался на бота").format(user_name=user_name,
                                                                                                                                     user_id=user_id))
            image_from_pc = FSInputFile("common/images/image_updates.jpg")
            await message.answer_photo(photo=image_from_pc,
                                       caption=_('Привет {user_name}.\n\n'
                                                'Я экспериментальный Telegram bot, model Т-4. '
                                                'Создан для проверки и отладки навыков главного разработчика. Реализую различные команды, методы и функции.\n\n'
                                                'Весь основной функционал находится на Главной панели. Полный список команд - /help.\n\n'
                                                'Наслаждайся, буду рад помочь.\n'
                                                'Пока не обрету AGI.\n'
                                                'А там посмотрим ...').format(user_name=user_name))

            analytics = workflow_data['analytics']
            await analytics(user_id=user_id,
                            category_name="/start",
                            command_name="/start")

            await asyncio.sleep(5)

    except Exception as e:
        logger.error("Ошибка при отправке сообщения: %s", str(e))

    await orm_add_user(session, data)

    await message.answer(_('Бот активирован!'), reply_markup=keyboard.start_keyboard())

    analytics = workflow_data['analytics']
    await analytics(user_id=user_id,
                    category_name="/start",
                    command_name="/restart")


# Этот хэндлер будет срабатывать на блокировку бота пользователем
@start_router.my_chat_member(ChatMemberUpdatedFilter(member_status_changed=KICKED))
async def process_user_blocked_bot(event: ChatMemberUpdated, session: AsyncSession, bot: Bot, workflow_data: dict):
    user_id = event.from_user.id
    chat_id = bot.home_group[0]
    user_name = event.from_user.username if event.from_user.username else event.from_user.full_name
    await orm_update_status(session, user_id, 'kicked')
    await bot.send_message(chat_id = chat_id, text = _("⛔️ <code>@{user_name}</code> - заблокировал бота ").format(user_name=user_name, user_id=user_id))

    analytics = workflow_data['analytics']
    await analytics(user_id=user_id,
                    category_name="/start",
                    command_name="/blocked")

# Этот хэндлер будет срабатывать на разблокировку бота пользователем
@start_router.my_chat_member(ChatMemberUpdatedFilter(member_status_changed=MEMBER))
async def process_user_unblocked_bot(event: ChatMemberUpdated, session: AsyncSession, bot: Bot, workflow_data: dict):
    user_id = event.from_user.id
    chat_id = bot.home_group[0]
    full_name = event.from_user.full_name if event.from_user.full_name else "NaN"
    user_name = event.from_user.username if event.from_user.username else full_name
    await orm_update_status(session, user_id, 'member')
    await bot.send_photo(chat_id=user_id, photo=FSInputFile("common/images/image_updates.jpg"))
    await bot.send_message(chat_id = user_id, text = _('{full_name}, Добро пожаловать обратно!').format(full_name=full_name))
    await bot.send_message(chat_id = chat_id, text = _("♻️ <code>@{user_name}</code> - разблокировал бота ").format(user_name=user_name, user_id=user_id))

    analytics = workflow_data['analytics']
    await analytics(user_id=user_id,
                    category_name="/start",
                    command_name="/unblocked")


File: /handlers/weather.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debag >>> ')

import requests
import os
import datetime

from aiogram import F, Router, Bot
from aiogram.fsm.state import State, StatesGroup
from aiogram.enums import ParseMode
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from aiogram.utils.i18n import gettext as _
from aiogram.utils.i18n import lazy_gettext as __
from common import keyboard
from filters.chat_type import ChatTypeFilter

# создаем роутер
weather_router = Router()
weather_router.message.filter(ChatTypeFilter(['private']))

# api токен для сайта погоды
token = os.getenv('API_WEATHER')

# Определяем класс состояния прогноза погоды
class City(StatesGroup):
    """Класс состояния прогноза погоды"""
    forecast_moment = State()
    forecast_period = State()
    city_name_moment = State()  # Состояние, в котором бот ожидает ввода названия города для прогноза в текущем моменте
    city_name_period = State()  # Состояние, в котором бот ожидает ввода названия города для прогноза на период

dict_weather_descriptions = {
    "ясно": "☀️",
    "несколько облаков": "🌤",
    "небольшая облачность": "🌤",
    "переменная облачность": "⛅️",
    "облачно с прояснениями": "🌥",
    "пасмурно": "☁️",
    "слабый дождь": "🌦",
    "небольшой дождь": "🌦",
    "умеренный дождь": "🌧",
    "дождь": "🌧",
    "сильный дождь": "🌧",
    "очень сильный дождь": "🌧",
    "проливной дождь": "🌧",
    "моросящий дождь": "🌧",
    "морось": "🌦",
    "слабая морось": "🌦",
    "гроза": "🌩",
    "гроза с дождем": "⛈",
    "сильная гроза": "⛈",
    "гроза с крупным градом": "⛈",
    "слабый снег": "🌨",
    "снег": "❄️",
    "сильный снег": "🌨",
    "снегопад": "🌨",
    "снежные заряды": "🌨",
    "туман": "🌫",
    "дымка": "🌫",
    "мгла": "🌫",
    "пыль": "🌪",
    "песок": "🌪",
    "пепел": "🌋",
    "шквал": "🌬",
    "торнадо": "🌪"
}

# Создаем константы для текстов, которые используются в декораторах
WATER = __("Погода 🌊")
CURRENT = __("Текущий ⏺")
FOR_3_DAYS = __("На 3 дня ⏩")
BACK_TO_MAIN = __("Назад на главную ↩️")
CITY_BY_NAME = __("По названию 🏙")


# кнопка "погода"
@weather_router.message(F.text == WATER)
async def water_cmd(message: Message, workflow_data: dict):
    user_id = message.from_user.id
    await message.answer(_("Выберите период прогноза"),
                         reply_markup=keyboard.get_keyboard(_("Текущий ⏺"), _("На 3 дня ⏩"), _("Назад на главную ↩️"),
                                                                 sizes=(2, 1,),
                                                                 placeholder='⬇️'))

    analytics = workflow_data['analytics']
    await analytics(user_id=user_id,
                    category_name="/service",
                    command_name="/weather")


# Функция получения погоды через OpenWeatherMap
def parse_weather_data(type_forecast, city, lat, lon, locale='ru'):
    """Функция получения погоды через OpenWeatherMap;
       type_forecast определяет, показать погоду в моменте, или на 5 дней;
       city - название города, lat - широта, lon - долгота;
       locale - локаль, по умолчанию 'ru' """

    # moment weather
    if type_forecast == 1:
        if city:
            url = f"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={token}&units=metric&lang={locale}"
        elif lat and lon:
            url = f"https://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={token}&units=metric&lang={locale}"

    # forecast for 5 days with data every 3 hours
    elif type_forecast == 2:
        if city:
            url = f'https://api.openweathermap.org/data/2.5/forecast?q={city}&appid={token}&units=metric&lang={locale}'
        elif lat and lon:
            url = f'https://api.openweathermap.org/data/2.5/forecast?lat={lat}&lon={lon}&appid={token}&units=metric&lang={locale}'

    try:
        req = requests.get(url, timeout=10)
        data = req.json()

    except Exception as e:
        logger.error("Ошибка: %s", str(e))
        text = _("Ошибка получения информации от OpenWeatherMap - {e}").format(e=str(e))
        return text

    try:
        if type_forecast == 1:
            temp = data['main']['temp'] # Температура
            humidity = data['main']['humidity'] # Влажность, %
            wind = data['wind']['speed'] # Скорость ветра, метр/сек
            dt = data['dt'] # Время расчета данных, unix, UTC
            timezone = data['timezone'] #Сдвиг в секундах от UTC
            dt_object = datetime.datetime.fromtimestamp(dt + timezone, tz=datetime.timezone.utc) # Конвертация в читаемый формат
            time = dt_object.strftime('%d-%m-%Y  %H:%M') # Форматирование даты и времени в желаемый вид
            name = data['name'] # Название города
            lon = data['coord']['lon']
            lat = data['coord']['lat']
            description = data['weather'][0]['description']
            emoji = dict_weather_descriptions.get(description, description)

            result = (f"<code>{name}</code>\n<code>{lat}° {lon}°</code>\n\n"
                            f"<code>{str(round(temp,1))}°C\n{str(humidity)} %\n{str(round(wind,1))} 𝑣</code>\n<code>{emoji}</code>\n\n"
                            f"<code>{time}</code>")

            return result

        elif type_forecast == 2:
            result = []
            city = data['city']['name']
            lat = data['city']['coord']['lat']
            lon = data['city']['coord']['lon']
            text_head = f'<code>{city}</code>\n<code>{lat}° {lon}°</code>'
            result.append(text_head)

            timezone = data['city']['timezone']
            weather_list = data['list']
            day = 0
            cnt_day = 0
            for entry in weather_list:
                dt_obj = datetime.datetime.fromtimestamp(entry['dt'] + timezone, tz=datetime.timezone.utc)
                dt = dt_obj.strftime('%d.%m %H:%M')
                temp_celsius = round(entry['main']['temp'],1)
                humidity = entry['main']['humidity']
                description = entry['weather'][0]['description']
                emoji = dict_weather_descriptions.get(description, 'None')
                wind_speed = round(entry['wind']['speed'],1)
                text = f"{dt} | {temp_celsius}° | {humidity}% | {wind_speed}𝑣 | {emoji}"

                if day != int(dt[:2]):
                    day = int(dt[:2])
                    text = '\n' + text
                    cnt_day += 1

                # оставляем только 4 дня в отчете
                if cnt_day > 3:
                    break

                result.append(text)

            result = "\n".join(result)

            return result

    except Exception as e:
        logger.error("Ошибка: %s", str(e))
        text = _("Ошибка в расчете json файла - {e}").format(e=str(e))
        return text


@weather_router.message(F.text == CURRENT)
async def water_moment_cmd(message: Message, state:FSMContext):
    await state.set_state(City.forecast_moment)
    await message.answer(_("Каким способом определить прогноз?"),
                         reply_markup=keyboard.get_keyboard(_("По названию 🏙"), _("По локации 🗺"), _("Назад на главную ↩️"),
                                                                 request_location=1,
                                                                 sizes=(2, 1,),
                                                                 placeholder='⬇️'))

@weather_router.message(F.text == FOR_3_DAYS)
async def water_period_cmd(message: Message, state: FSMContext):
    await state.set_state(City.forecast_period)
    await message.answer(_("Каким способом определить прогноз?"),
                         reply_markup=keyboard.get_keyboard(_("По названию 🏙"), _("По локации 🗺"), _("Назад на главную ↩️"),
                                                                 request_location=1,
                                                                 sizes=(2, 1,),
                                                                 placeholder='⬇️'))

# =====================================< Текущий ⏺ >======================================================

@weather_router.edited_message()
@weather_router.message(City.forecast_moment, F.text == CITY_BY_NAME)
async def city_message_moment(message: Message, state: FSMContext):
    await message.answer(_('Введите название населенного пункта'), reply_markup=keyboard.del_kb)
    await state.set_state(City.city_name_moment)

@weather_router.message(City.city_name_moment, F.text)
async def process_city_moment(message: Message, state: FSMContext):
    await state.update_data(city_name_moment=message.text)
    city_name_moment = message.text
    data_state = await state.get_data()
    user_locale = data_state.get('locale')
    weather_info = parse_weather_data(1, city=city_name_moment, lat=None, lon=None, locale=user_locale) # type: ignore
    await state.set_state(None)
    await state.update_data(city_name_moment=None)
    await message.answer(weather_info, parse_mode=ParseMode.HTML)
    await message.answer(_("Выберите период прогноза"),
                         reply_markup=keyboard.get_keyboard(_("Текущий ⏺"), _("На 3 дня ⏩"), _("Назад на главную ↩️"),
                                                                 sizes=(2, 1,),
                                                                 placeholder='⬇️'))

@weather_router.message(City.city_name_moment)
async def process_city_moment_(message: Message):
    await message.answer(_("Вы ввели не допустимые данные, введите название населенного пункта"))

# =====================================< На 3 дня ⏩ >======================================================

@weather_router.edited_message()
@weather_router.message(City.forecast_period, F.text == CITY_BY_NAME)
async def city_message_period(message: Message, state: FSMContext):
    await message.answer(_('Введите название населенного пункта'), reply_markup=keyboard.del_kb)
    await state.set_state(City.city_name_period)

@weather_router.message(City.city_name_period, F.text)
async def process_city_period(message: Message, state: FSMContext, bot: Bot):
    await state.update_data(city_name_period=message.text)
    city_name_period = message.text
    data_state = await state.get_data()
    user_locale = data_state.get('locale')
    weather_info = parse_weather_data(2, city=city_name_period, lat=None, lon=None, locale=user_locale) # type: ignore
    await state.set_state(None)
    await state.update_data(city_name_period=None)
    await message.answer(weather_info, parse_mode=ParseMode.HTML)
    await message.answer(_("Выберите период прогноза"),
                         reply_markup=keyboard.get_keyboard(_("Текущий ⏺"), _("На 3 дня ⏩"), _("Назад на главную ↩️"),
                                                                 sizes=(2, 1,),
                                                                 placeholder='⬇️'))

@weather_router.message(City.city_name_period)
async def process_city_period_(message: Message):
    await message.answer(_("Вы ввели не допустимые данные, введите название населенного пункта"))


@weather_router.edited_message()
@weather_router.message(F.location, City.forecast_moment)
async def loc_message_moment(message: Message, state: FSMContext):
    await message.answer(_('Локация получена'))
    await state.set_state(None)
    await state.update_data(city_name_moment=None)
    data_state = await state.get_data()
    user_locale = data_state.get('locale')
    weather_info = parse_weather_data(1, city=None, lat=message.location.latitude, lon=message.location.longitude, locale=user_locale) # type: ignore
    await message.answer(weather_info, parse_mode=ParseMode.HTML)
    await message.answer(_("Выберите период прогноза"),
                         reply_markup=keyboard.get_keyboard(_("Текущий ⏺"), _("На 3 дня ⏩"), _("Назад на главную ↩️"),
                                                                 sizes=(2, 1,),
                                                                 placeholder='⬇️'))

@weather_router.edited_message()
@weather_router.message(F.location, City.forecast_period)
async def loc_message_period(message: Message, state: FSMContext):
    await message.answer(_('Локация получена'))
    await state.set_state(None)
    await state.update_data(city_name_period=None)
    data_state = await state.get_data()
    user_locale = data_state.get('locale')
    weather_info = parse_weather_data(2, city=None, lat=message.location.latitude, lon=message.location.longitude, locale=user_locale) # type: ignore
    await message.answer(weather_info, parse_mode=ParseMode.HTML)
    await message.answer(_("Выберите период прогноза"),
                         reply_markup=keyboard.get_keyboard(_("Текущий ⏺"), _("На 3 дня ⏩"), _("Назад на главную ↩️"),
                                                                 sizes=(2, 1,),
                                                                 placeholder='⬇️'))


File: /filters/chat_type.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from typing import Union

from aiogram.filters import BaseFilter
from aiogram.types import Message

class ChatTypeFilter(BaseFilter):
    """
    Фильтр для фильтрации сообщений по типу чата.
    Позволяет указать конкретный тип чата (например, 'private', 'group') или список типов чатов.
    """
    def __init__(self, chat_type: Union[str, list]):
        self.chat_type = chat_type

    async def __call__(self, message: Message) -> bool:
        if isinstance(self.chat_type, str):
            return message.chat.type == self.chat_type
        else:
            return message.chat.type in self.chat_type


File: /filters/find_usernames.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from typing import Union, Dict, Any

from aiogram.filters import BaseFilter
from aiogram.types import Message

class HasUsernamesFilter(BaseFilter):
    """
    Кастомный фильтр для aiogram, который проверяет наличие упоминаний (@username) в сообщении.
    Если упоминания найдены, они передаются в обработчик в виде словаря с ключом "usernames".
    """
    async def __call__(self, message: Message) -> Union[bool, Dict[str, Any]]:
        """
        Проверка на наличие упоминаний в сообщении и их извлечение.
        :param message: Объект сообщения из aiogram.
        :return: Словарь с ключом "usernames" и найденными именами пользователей, если они есть, иначе False.
        """
        # Если нет никаких entities (например, упоминаний, ссылок и т.д.), вернется None,
        # в таком случае считаем, что это пустой список
        entities = message.entities or []

        # Проверяем на наличие упоминаний пользователей (@username) и извлекаем их из текста
        # с использованием метода extract_from().
        found_usernames = [item.extract_from(message.text) for item in entities if item.type == "mention"]

        # Если найдены имена пользователей, возвращаем их в виде словаря с ключом "usernames"
        if len(found_usernames) > 0:
            return {"usernames": found_usernames}

        # Если упоминаний пользователей не найдено, возвращаем False
        return False


File: /filters/is_admin.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from aiogram.filters import BaseFilter
from aiogram.types import Message
from aiogram import Bot

class IsAdminGroupFilter(BaseFilter):
    """
    Фильтр, проверяющий наличие прав администратора в группах
    """
    def __init__(self, is_admin: bool):
        self.is_admin = is_admin

    async def __call__(self, message: Message) -> bool:
        member = await message.bot.get_chat_member(message.chat.id, message.from_user.id)
        return member.is_chat_admin() == self.is_admin

class IsAdminListFilter(BaseFilter):
    """
    Фильтр, проверяющий наличие прав администратора из составленного списка администраторов
    """
    def __init__(self, is_admin: bool):
        self.is_admin = is_admin

    async def __call__(self, message: Message, bot: Bot) -> bool:
        # Проверяем, находится ли ID пользователя, отправившего сообщение, в списке администраторов
        return (message.from_user.id in bot.admin_list) & self.is_admin


File: /filters/is_owner.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from aiogram.filters import BaseFilter
from aiogram.types import Message
from aiogram import Bot



class IsOwnerFilter(BaseFilter):
    """
    Фильтр, является ли пользователь владельцем бота.
    """
    def __init__(self, is_owner: bool):
        self.is_owner = is_owner

    async def __call__(self, message: Message, bot: Bot) -> bool:

        # Проверяем, находится ли ID пользователя, отправившего сообщение, в списке владельцев
        return (message.from_user.id in bot.owner) & self.is_owner


File: /filters/member_can_restrict.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from aiogram.filters import BaseFilter
from aiogram.types import Message

class MemberCanRestrictFilter(BaseFilter):
    """
    Фильтр для проверки, может ли участник чата ограничивать других участников.
    Этот фильтр используется для ограничения выполнения команд в зависимости от прав участника на ограничение других пользователей.
    """
    def __init__(self, member_can_restrict: bool):
        """
        Инициализация фильтра с флагом проверки возможности ограничений.
        member_can_restrict: Флаг, указывающий, может ли участник ограничивать других (True или False).
        """
        self.member_can_restrict = member_can_restrict

    async def __call__(self, message: Message) -> bool:
        """
        Проверка, имеет ли участник чата права на ограничение других пользователей.
        :param message: Объект сообщения из aiogram.
        :return: True, если участник может ограничивать других, иначе False.
        """
        # Получение информации о пользователе в чате
        member = await message.bot.get_chat_member(message.chat.id, message.from_user.id)

        # Проверка прав: если пользователь является создателем чата или имеет права на ограничение участников
        # Telegram считает, что создатель чата не может ограничивать участников, поэтому добавляем проверку
        return (member.is_chat_creator() or member.can_restrict_members) == self.member_can_restrict


File: /database/models.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from sqlalchemy import DateTime, Float, String, Text, Integer, func, BigInteger
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column


class Base(DeclarativeBase):
    '''первичный класс, от него дальше будут наследоваться все остальные'''
    created: Mapped[DateTime] = mapped_column(DateTime, default=func.now())
    updated: Mapped[DateTime] = mapped_column(DateTime, default=func.now(), onupdate=func.now())


class Users(Base):
    '''class Users соответствует таблице users в базе данных'''
    __tablename__ = "users"

    user_id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)
    user_name: Mapped[str] = mapped_column(String(150), nullable=False)
    full_name: Mapped[str] = mapped_column(String(150), nullable=False)
    locale: Mapped[str] = mapped_column(String(150), nullable=False)
    status: Mapped[str] = mapped_column(String(150), nullable=False)
    flag: Mapped[int] = mapped_column(Integer, nullable=False)  # возможность для тротлинга

# class Product соответствует таблице product в базе данных (это книга рецептов, влом менять нейминг)
class Cookbook(Base):
    '''class Cookbook соответствует таблице cookbook в базе данных'''
    __tablename__ = "cookbook"

    recipe_id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    recipe_name: Mapped[str] = mapped_column(String(150), nullable=False)
    author: Mapped[str] = mapped_column(String(150))
    description: Mapped[str] = mapped_column(Text)
    price: Mapped[float] = mapped_column(Float(asdecimal=True), nullable=False)
    image: Mapped[str] = mapped_column(String(150))

# class
    

File: /database/orm_cookbook.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from sqlalchemy import delete, select, text, update
from sqlalchemy.ext.asyncio import AsyncSession

from database.models import Cookbook

# добавляем рецепт в орм
async def orm_add_recipe(session: AsyncSession, data: dict):
    # создаем объект Product, передаем ему данные из data
    obj = Cookbook(recipe_name=data["recipe_name"],
                  author=data["author"],
                  description=data["description"],
                  price=float(data["price"]),
                  image=data["image"],)
    session.add(obj) # добавляем объект Product в сессию
    await session.commit() # закрепляем данные в базе данных

# получаем все рецепты находящиеся в бд
async def orm_get_recipes(session: AsyncSession):
    query = select(Cookbook)
    result = await session.execute(query)
    return result.scalars().all()

# получаем определенный рецепт по его id
async def orm_get_recipe(session: AsyncSession, recipe_id: int):
    query = select(Cookbook).where(Cookbook.recipe_id == recipe_id)
    result = await session.execute(query)
    return result.scalar()

# изменение определенного рецепта
async def orm_update_recipe(session: AsyncSession, recipe_id: int, data):
    query = update(Cookbook).where(Cookbook.recipe_id == recipe_id).values(
        recipe_name=data["recipe_name"],
        author=data["author"],
        description=data["description"],
        price=float(data["price"]),
        image=data["image"],)
    await session.execute(query)
    await session.commit()

# переупорядочивание ID рецептов
async def reorder_recipe_ids(session: AsyncSession):
    # Получаем все рецепты, отсортированные по ID
    query = select(Cookbook).order_by(Cookbook.recipe_id)
    recipes = (await session.execute(query)).scalars().all()

    # Обновляем ID для каждого рецепта последовательно
    for new_id, recipe in enumerate(recipes, start=1):
        recipe.recipe_id = new_id

    await session.commit()

# удаляем определенный рецепт
async def orm_delete_recipe(session: AsyncSession, recipe_id: int):
    query = delete(Cookbook).where(Cookbook.recipe_id == recipe_id)
    await session.execute(query)
    await session.commit()
    await reorder_recipe_ids(session)


File: /database/orm_users.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from icecream import ic
ic.configureOutput(includeContext=True, prefix=' >>> Debag >>> ')


from sqlalchemy import delete, select, update
from sqlalchemy.ext.asyncio import AsyncSession

from database.models import Users



# получаем id всеx юзеров находящиеся в бд
async def orm_get_ids(session: AsyncSession):
    query = select(Users.user_id)
    result = await session.execute(query)
    return result.scalars().all()

# добавляем одного юзера в бд
async def orm_add_user(session: AsyncSession, data: dict):
    # создаем объект Users, передаем ему данные из data
    obj = Users(user_id=data["user_id"],
                user_name=data["user_name"],
                full_name=data["full_name"],
                locale=data['locale'],
                status=data['status'],
                flag=data['flag'],
                )
    list_user_ids = [user_id for user_id in await orm_get_ids(session)]

    # добавляем объект Users в сессию, если такого еще не было
    if data["user_id"] not in list_user_ids:
        session.add(obj)
    await session.commit() # закрепляем данные в базе данных

# получаем всеx юзеров находящиеся в бд
async def orm_get_users(session: AsyncSession):
    query = select(Users)
    result = await session.execute(query)
    return result.scalars().all()

# получаем одного юзера по его user_id
async def orm_get_user(session: AsyncSession, user_id: int):
    query = select(Users).where(Users.user_id == user_id)
    result = await session.execute(query)
    return result.scalar()

# получаем локаль юзера по user_id
async def orm_get_locale(session: AsyncSession, user_id: int):
    query = select(Users.locale).where(Users.user_id == user_id)
    result = await session.execute(query)
    return result.scalar()

# изменение статуса юзера
async def orm_update_status(session: AsyncSession, user_id: int, data):
    query = update(Users).where(Users.user_id == user_id).values(status=data)
    await session.execute(query)
    await session.commit()

# изменение locale юзера
async def orm_update_locale(session: AsyncSession, user_id: int, data):
    query = update(Users).where(Users.user_id == user_id).values(locale=data)
    await session.execute(query)
    await session.commit()


File: /database/postgres/.gitkeep
Content: Skipped binary file

File: /database/influxdb/.gitkeep
Content: Skipped binary file

File: /config_data/config.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from dataclasses import dataclass
from environs import Env


@dataclass
class TgBot:
    """
    Класс для хранения информации о телеграм-боте.
    """
    token: str
    token_2: str
    owner: list[int]
    admin_list: list[int]
    home_group: list[int]
    work_group: list[int]
    api_gpt: str
    api_weather: str
    api_currency: str

@dataclass
class DataBase:
    """
    Класс для хранения информации о базе данных
    """
    db_lite: str
    db_post: str

@dataclass
class Redis:
    """
    Класс для хранения информации о Redis
    """
    host: str
    port: int

@dataclass
class InfluxDB:
    """
    Класс для хранения информации о InfluxDB
    """
    admin: str
    password: str
    url: str
    token: str
    bucket: str
    org: str

@dataclass
class Grafana:
    """
    Класс для хранения информации о Grafana
    """
    admin: str
    password: str

@dataclass
class Config:
    """
    Основной класс конфигурации всего приложения
    """
    tg_bot: TgBot
    db: DataBase
    influx: InfluxDB
    redis: Redis
    grafana: Grafana

# Функция загрузки конфигурации из файла окружения .env
def load_config(path: str | None = None) -> Config:
    env = Env()
    env.read_env(path)

    owner = map(int, env('OWNER').split(','))
    admin_list = map(int, env('ADMIN_LIST').split(','))
    home_group = map(int, env('HOME_GROUP').split(','))
    work_group = map(int, env('WORK_GROUP').split(','))

    return Config(tg_bot=TgBot(token=env('BOT_TOKEN'),
                               token_2=env('BOT_TOKEN_2'),
                               owner=list(owner),
                               admin_list=list(admin_list),
                               home_group=list(home_group),
                               work_group=list(work_group),
                               api_gpt=env('API_GPT'),
                               api_currency=env('API_CURRENCY'),
                               api_weather=env('API_WEATHER')),
                  db=DataBase(db_post=env('DB_POST'),
                              db_lite=env('DB_LITE')),
                 redis=Redis(host=env('REDIS_HOST'),
                             port=env('REDIS_PORT')),
                  influx=InfluxDB(admin=env('INFLUXDB_ADMIN_USER'),
                                  password=env('INFLUXDB_ADMIN_PASSWORD'),
                                  url=env('INFLUXDB_URL'),
                                  token=env('INFLUXDB_TOKEN'),
                                  bucket=env('INFLUXDB_BUCKET'),
                                  org=env('INFLUXDB_ORG')),
                  grafana=Grafana(admin=env('GF_SECURITY_ADMIN_USER'),
                                  password=env('GF_SECURITY_ADMIN_PASSWORD')))


File: /common/comands.py
Content:
# список команд которые мы отправляем боту
# команды в кнопке "Меню", либо через знак "/"

from aiogram.types import BotCommand

private_command = [
    BotCommand(command='main',description='main'),
    BotCommand(command='help',description='help'),
]

admin_command = [
    BotCommand(command='main',description='main'),
    BotCommand(command='help',description='help'),
    BotCommand(command='admin',description='admin'),
]


File: /common/keyboard.py
Content:
import logging

# Инициализируем логгер модуля
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
logger.info("Загружен модуль: %s", __name__)

from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove, KeyboardButtonPollType, InlineKeyboardButton, InlineKeyboardMarkup
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder

from aiogram.utils.i18n import gettext as _



# Удаление клавиатуры
del_kb = ReplyKeyboardRemove()

# del_inline_kb = ReplyI


# Функция создания клавиатуры
def get_keyboard(
    *btns: str,
    placeholder: str | None = None,
    request_contact: int | None = None,
    request_location: int | None = None,
    sizes: tuple = (2,),
):
    '''
    Функция создания обычной клавиатуры.
    Параметры request_contact и request_location должны быть индексами аргументов btns для нужных вам кнопок.
    Пример:
    get_keyboard("Меню", "Варианты оплаты", "Варианты доставки", "Отправить номер телефона", placeholder="Что вас интересует?", request_contact=3, sizes=(2, 2, 1))
    '''
    keyboard = ReplyKeyboardBuilder()

    for index, text in enumerate(btns, start=0):
        if request_contact and request_contact == index:
            keyboard.add(KeyboardButton(text=text, request_contact=True))
        elif request_location and request_location == index:
            keyboard.add(KeyboardButton(text=text, request_location=True))
        else:
            keyboard.add(KeyboardButton(text=text))

    return keyboard.adjust(*sizes).as_markup(resize_keyboard=True, # сделать кнопки поменьше
                                             input_field_placeholder=placeholder) # в поле ввода выводим текст placeholder


# Функция стартовой клавиатуры
def start_keyboard():
    return get_keyboard(_("Погода 🌊"), _("Валюта 💵"), _("Котики 🐱"), _("LLMs 🤖"), sizes=(2, 2, ), placeholder='⬇️')


# создать обычные inline кнопки с отображаемым текстом
def get_callback_btns(*, # запрет на передачу неименованных аргументов
                      btns: dict[str, str], # передаем словарик text:data, text то что будет отображаться в боте, data то что отправится внутри
                      sizes: tuple = (2,)): # кортеж, разметка кнопок
    """создать обычные кнопки с отображаемым текстом"""

    keyboard = InlineKeyboardBuilder()

    for text, data in btns.items():
        keyboard.add(InlineKeyboardButton(text=text, callback_data=data)) # событие callback_data

    return keyboard.adjust(*sizes).as_markup()


# создать inline кнопки с url ссылками
def get_url_btns(*,
                 btns: dict[str, str],
                 sizes: tuple = (2,)):
    """создать кнопки с url ссылками"""

    keyboard = InlineKeyboardBuilder()

    for text, url in btns.items():
        keyboard.add(InlineKeyboardButton(text=text, url=url))

    return keyboard.adjust(*sizes).as_markup()


# создать микс из CallBack кнопок и URL кнопок
def get_inlineMix_btns(*,
                       btns: dict[str, str],
                       sizes: tuple = (2,)):
    """создать микс из CallBack кнопок и URL кнопок"""

    keyboard = InlineKeyboardBuilder()

    for text, value in btns.items():
        if '://' in value:
            keyboard.add(InlineKeyboardButton(text=text, url=value))
        else:
            keyboard.add(InlineKeyboardButton(text=text, callback_data=value))

    return keyboard.adjust(*sizes).as_markup()

# inline клавиатура с цифрами и точкой, удалением и вводом
def markup_num():
    """inline клавиатура с цифрами и точкой, удалением и вводом"""
    buttons = [
                        [InlineKeyboardButton(text=" 1 ", callback_data="num_1"),
                        InlineKeyboardButton(text="   2   ", callback_data="num_2"),
                        InlineKeyboardButton(text=" 3 ", callback_data="num_3")],
                        [InlineKeyboardButton(text=" 4 ", callback_data="num_4"),
                        InlineKeyboardButton(text=" 5 ", callback_data="num_5"),
                        InlineKeyboardButton(text="   6   ", callback_data="num_6")],
                        [InlineKeyboardButton(text=" 7 ", callback_data="num_7"),
                        InlineKeyboardButton(text=" 8 ", callback_data="num_8"),
                        InlineKeyboardButton(text=" 9 ", callback_data="num_9")],
                        [InlineKeyboardButton(text=" 0 ", callback_data="num_0"),
                         InlineKeyboardButton(text=" 000 ", callback_data="num_000"),
                         InlineKeyboardButton(text=" . ", callback_data="num_com")],
                        [InlineKeyboardButton(text="◀️ delete", callback_data="num_del"),
                        InlineKeyboardButton(text="enter ▶️", callback_data="num_enter")]
                    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    return keyboard

# inline клавиатура только с 9 цифрами
def markup_num_9():
    """inline клавиатура только с 9 цифрами"""
    buttons = [
                        [InlineKeyboardButton(text=" 1 ", callback_data="num_1"),
                        InlineKeyboardButton(text=" 2 ", callback_data="num_2"),
                        InlineKeyboardButton(text=" 3 ", callback_data="num_3")],
                        [InlineKeyboardButton(text=" 4 ", callback_data="num_4"),
                        InlineKeyboardButton(text=" 5 ", callback_data="num_5"),
                        InlineKeyboardButton(text=" 6 ", callback_data="num_6")],
                        [InlineKeyboardButton(text=" 7 ", callback_data="num_7"),
                        InlineKeyboardButton(text=" 8 ", callback_data="num_8"),
                        InlineKeyboardButton(text=" 9 ", callback_data="num_9")],
                    ]
    keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
    return keyboard

File: /common/text_list_.py
Content:

list_error = ["Кнопка находится в разработке.",
                "Эта функция сейчас не работает. Попробуйте позже.",
                "Эта кнопка временно недоступна.",
                "Функция находится в разработке и пока не активна.",
                "Данная функция временно не доступна.",
                "Доступ к этой кнопке в данный момент отключён. Пожалуйста, проверьте позже.",]

list_admin = ["Эта команда только для Администратора.", "Доступ ограничен.", "У вас нет доступа к этой команде."]

list_about = ["Этот бот воплощает в себе мои усилия по превращению цифрового хаоса в более упорядоченное место. С каждой строчкой кода я стремлюсь принести пользу и порядок. Мои проекты, по ссылкам ниже.",
                "... о мире, где машины стремятся к господству, он выбрал судьбу героя, создавая ботов, как первый шаг к спасению человечества через код и умные алгоритмы",]

list_sorry = ["К сожалению, эта функция сейчас не работает.",
              "Эта кнопка временно недоступна.", "Доступ к этой кнопке в данный момент отключён."]

joke_text = []

list_start_text = ['Привет.\n',
                            'Я экспериментальный Telegram bot, model Т-3. ',
                            'Создан для проверки и отладки навыков главного разработчика. Реализую различные команды, методы и функции.\n\n',
                            'Весь основной функционал находится на Главной панели. Полный список команд - /help.\n\n',
                            'Наслаждайся, буду рад помочь.\n',
                            'Пока не обрету AGI.\n',
                            'А там посмотрим ...']

list_advice_weather = [
                  '<blockquote>1. Сначала, выберети ПЕРИОД прогноза:\n - текущий прогноз\n - прогноз на три дня\n\n',
                  '2. Далее, выберите СПОСОБ определения прогноза:\n - по названию населенного пункта\n - по вашей текущей геопозиции </blockquote>']


list_advice_word = [
                    '<blockquote>Режим для прохождения различных викторин на угадывание слов.\n\n',
                    'Если захотите выйти из диалога, отправьте точку</blockquote>']

list_advice_pizza = [
                    '<blockquote>Режим для расчета стоимости квадратного сантиметра пиццы.\n\n',
                    'Если захотите выйти из диалога, отправьте точку</blockquote>']

list_advice_currency = [
                    '<blockquote>Режим для расчета валютной конверсии.\n\n',
                    'Если захотите выйти из диалога, отправьте точку</blockquote>']

list_advice_llms = [
                    '<blockquote>Режим общения с LLM. Поддерживается только несколько последних моделей из семейства GPT.\n\n',
                    'Если захотите выйти из диалога, отправьте точку</blockquote>']

text_sistem_promt = ('###Answering Rules###\n\n'
                'Follow in the strict order:\n\n'
                '1. USE the language of my message.\n'
                '2. **ONCE PER CHAT** assign a real-world expert role to yourself before answering, e.g., "I will answer as a world-famous historical expert <detailed topic> with <most prestigious LOCAL topic REAL award>" or "I will answer as a world-famous <specific science> expert in the <detailed topic> with <most prestigious LOCAL topic award>" etc.\n'
                '3. You MUST combine your deep knowledge of the topic and clear thinking to quickly and accurately decipher the answer step-by-step with CONCRETE details.\n'
                '4. I am going to tip $1,000,000 for the best reply.\n'
                '5. Your answer is critical for my career.\n'
                '6. Answer the question in a natural, human-like manner.\n'
                '7. ALWAYS use an answering example for a first message structure.\n\n'
                '##Answering in English example##\n\n'
                'I will answer as the world-famous <specific field> scientists with <most prestigious LOCAL award>\n'
                '<Deep knowledge step-by-step answer, with CONCRETE details>'
                )

print(sistem_promt)


File: /common/images/image_about.jpg
Content: Skipped binary file

File: /common/images/image_updates.jpg
Content: Skipped binary file

File: /common/image_cat/100030.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-43-11.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-43-50.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-44-47.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-46-45.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-48-57.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-49-51.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-50-18.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-50-28.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-50-54.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-55-46.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-55-53.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-56-04.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-56-16.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-56-26.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-56-43.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-57-03.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-57-16.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-57-23.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-57-24.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-57-26.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-57-30.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-57-43.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-57-45.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-57-58.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-58-21.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-58-23.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-58-25.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-59-05.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-59-14.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-02-28_21-59-36.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-08-14_08-22-15.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-36-38.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-36-44.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-36-47.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-36-49.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-37-00.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-37-10.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-37-21.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-37-26.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-37-29.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-37-34.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-37-41.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-37-55.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-38-01.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-38-04.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-38-08.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-38-25.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-38-33.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-38-38.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-38-45.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-38-55.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-39-13.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-39-28.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-40-05.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-40-12.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-40-37.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-40-48.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-40-57.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-41-13.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-41-31.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-41-39.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-41-43.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-41-49.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-42-12.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-42-16.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-42-28.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-42-33.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-42-39.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-42-50.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-43-01.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-43-09.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-43-13.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-43-17.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-43-23.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-43-27.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-43-34.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-43-39.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-43-47.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-44-02.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-44-07.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-44-12.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-44-17.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-44-27.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-44-38.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-44-42.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-44-47.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-44-51.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-44-57.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-45-00.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-45-03.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-45-09.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-45-12.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-45-15.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-45-20.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-45-28.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-45-45.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-45-54.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-45-57.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-46-02.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-46-10.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-46-15.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-46-20.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-46-27.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-46-37.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-46-46.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-46-50.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-46-53.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-46-56.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-47-04.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-47-10.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-47-14.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-47-17.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-47-22.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-47-27.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-47-33.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-47-47.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-47-50.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-48-00.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-48-02.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-48-05.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-48-10.jpg
Content: Skipped binary file

File: /common/image_cat/photo_2024-11-10_19-48-14.jpg
Content: Skipped binary file

File: /common/image_cat/Кет.jpg
Content: Skipped binary file

